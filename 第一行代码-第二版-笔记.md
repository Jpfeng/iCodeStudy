# 第一行代码 Android 第2版

<h2 id="index">目录</h2>

- [第1章 开始](#chap1)
- [第2章 Activity](#chap2)
- [第3章 UI布局](#chap3)
- [第4章 Fragment](#chap4)
- [第5章 BroadCast](#chap5)
- [第6章 数据持久化](#chap6)
- [第7章 Content Provider](#chap7)
- [第8章 多媒体](#chap8)
- [第9章 网络](#chap9)
- [第10章 Service](#chap10)
- [第11章 定位](#chap11)
- [第12章 Material Design](#chap12)
- [第13章 高级技巧](#chap13)
- [第14章 酷欧天气](#chap14)
- [第15章 发布应用](#chap15)
- [Git 时间](#git)

------

<h2 id="chap1">第1章 开始</h2>

### Android 系统架构

| ·     | 架构         |
| :---: | ------------ |
| 顶层  | 应用层       |
| ↑     | 应用框架层   |
| ↑     | 系统运行库层 |
| 底层  | Linux内核层  |

### 搭建开发环境

安装 Android Studio → 配置 Android Studio → 创建项目 → 创建模拟器 → 运行项目

### 日志工具

Android 中提供了 Log 工具类 `android.util.Log` ，其中提供了5个方法用来输出不同级别的日志。

```java
Log.v(String tag, String msg); // 对应级别 verbose ，用来打印最琐碎的信息
Log.d(String tag, String msg); // 对应级别 debug ，用来打印调试信息
Log.i(String tag, String msg); // 对应级别 info ，用来打印比较重要的信息
Log.w(String tag, String msg); // 对应级别 warn ，用来打印警告信息
Log.e(String tag, String msg); // 对应级别 error ，用来打印程序错误
```

输出的日志会显示在 logcat 中。logcat 可以通过以下三种方式过滤日志。

- [过滤器](#filter.1)
- [日志级别控制](#filter.2)
- [关键字过滤](#filter.3)

<h4 id="filter.1">过滤器</h4>

有三种过滤器：'show only selected application', 'Firebase', 'No Filters'。除此之外，还可以使用 'Edit Filter Configuration' 自定义过滤器。

<h4 id="filter.2">日志级别控制</h4>

logcat中有5个级别，分别对应 Log 工具类中的5个级别。

<h4 id="filter.3">关键字过滤</h4>

关键字过滤支持正则表达式。

[↑目录](#index)

------

<h2 id="chap2">第2章 Activity</h2>

Activity 是一种可以包含用户界面的组件，主要用于和用户进行交互。

### 使用 Activity

创建 Activity → 创建 Layout 并加载 → 在 Manifest 中注册

### 使用 Toast

Android 中提供了 Toast 组件 `android.widget.Toast` ，可以通过静态方法 `makeText()` 进行创建。

```java
Toast.makeText(Context context, CharSequence text, @Duration int duration);
```

`makeText()` 方法需要3个参数， `context` 为上下文对象， `text` 为 Toast 显示的内容， `duration` 为 Toast 的持续时间，可取值为 `Toast.LENGTH_LONG` 和 `Toast.LENGTH_SHORT` 。

### 使用 Menu

新建 Menu 资源文件 → 重写 `OnCreateOptionsMenu()` 方法，通过 `MenuInflater.inflate()` 方法创建菜单 → 重写 `OnOptionsItemSelected()` 处理选择事件

### 销毁 Activity

使用 Activity 中的 `finish()` 方法。此方法效果等同于按下返回键。

### 使用 Intent

在 Activity 之间跳转需要使用 `android.content.Intent` 类。Intent大致可以分两种：**显式 Intent** 和**隐式 Intent** 。

#### 显式 Intent

显式 Intent 通过 `Intent(Context, Class<?>)` 来进行构造。 `packageContext` 参数传入当前应用的上下文对象， `cls` 参数传入目标 Activity 。然后，我们可以通过 Activity 中的 `startActivity(Intent intent)` 方法来启动目标 Activity。

```java
Intent intent = new Intent(context, TargetActivity.class);
startActivity(intent);
```

#### 隐式 Intent

隐式 Intent 并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的 `action` 和 `category` 等信息，然后交由系统去分析这个 Intent，并帮我们找出合适的活动去启动。通过在 `AndroidManifest.xml` 中的 `<activity>` 标签下配置 `<intent-filter>` 的内容， 可以指定当前 Activity 能够响应的 action 和 category。每个 Intent 中只能指定一个 action，但却能指定多个 category。

```xml
<activity android:name=".TargetActivity">
    <intent-filter>
        <action android:name="com.example.activitytest.ACTION_START"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <category android:name="com.example.activitytest.MY_CATEGORY">
    </intent-filter>
</activity>
```

接下来，我们就可以通过 `Intent(String)` 来构造 Intent。

```java
Intent intent = new Intent("com.example.activitytest.ACTION_START");
intent.addCategory("com.example.activitytest.MY_CATEGORY");
startActivity(intent);
```

使用隐式 Intent，我们不仅可以启动自己程序内的 Activity， 还可以启动其他程序的 Activity。

```java
Intent intent = new Intent(Intent.ACTION_VIEW);
intent.setData(Uri.parse("http://www.bing.com"));
startActivity(intent);
```

`setData()` 接收一个 `Uri` 对象，主要用于指定当前 Intent 正在操作的数据，而这些数据通常都是以字符串的形式传入到 `Uri.parse()` 方法中解析产生的。与此对应，我们可以在`<intent-filter>` 标签中再配置一个 `<data>` 标签，用于更精确地指定当前 Activity 能够响应什么类型的数据。只有 `<data>` 标签中指定的内容和 Intent 中携带的 Data 完全一致时， 当前 Activity 才能够响应该 Intent。 `<data>` 标签中主要可以配置以下内容。

- android:scheme 用于指定数据的协议部分。
- android:host 用于指定数据的主机名部分。
- android:port 用于指定数据的端口部分。
- android:path 用于指定主机名和端口之后的部分。
- android:mimeType 用于指定可以处理的数据类型，允许使用通配符的方式进行指定。

### Activity 间的数据传递

Intent 可以在 Activity 之间传递数据。

#### 向下一个 Activity 传递数据

Intent 中提供了一系列 `putExtra()` 方法的重载。可以通过该方法将数据暂存在 Intent 中，在目标 Activity 中从 Intent 取出就可以了。

```java
// 当前 Activity
String data1 = "Hello Target Activity";
int data2 = 123;
boolean data3 = true;
Intent intent = new Intent(context, TargetActivity.class);
intent.putExtra("string_extra", data1);
intent.putExtra("int_extra", data2);
intent.putExtra("boolean_extra", data3);
startActivity(intent);
```

```java
// 目标 Activity
Intent intent = getIntent();
String data1 = intent.getStringExtra("string_extra");
int data2 = intent.getIntExtra("int_extra", DEFAULT_INT);
boolean data3 = intent.getBooleanExtra("boolean_extra", DEFAULT_BOOLEAN);
```

#### 返回数据给上一个 Activity 并接收

Activity 中有一个 `startActivityForResult(Intent, int)` 方法，这个方法期望在 Activity 销毁的时候能够返回一个结果。第一个参数为 `Intent` ，第二个参数是请求码，需要是唯一值，用于在回调中判断数据的来源。

```java
Intent intent = new Intent(context, TargetActivity.class);
startActivityForResult(intent, REQUEST_TARGET);
```

在目标 Activity 中，可以构造一个新的 Intent 暂存数据，然后调用 `setResult(int, Intent)` 方法。第一个参数用于向上一个 Activity 返回处理结果，一般使用 `Activity.RESULT_OK` 或 `Activity.RESULT_CANCELED` 两个值，第二个参数把带有数据的 Intent 传递回去。最后调用 `finish()` 销毁 Activity。

```java
String data = "Hello Previous Activity";
Intent intent = new Intent();
intent.putExtra("data_result", data);
setResult(intent, RESULT_OK);
finish();
```

如果想要处理用户点击返回键时回传的数据，可以重写 `onBackPressed()` 方法。

在 TargetActivity 销毁后，会回调上一个 Activity 的 `onActivityResult(int, int, Intent)` 方法。我们需要重写上一个 Activity 中的 `onActivityResult(int, int, Intent)` 方法来接收回传数据。 `requestCode` 为我们在启动 TargetActivity 时传入的请求码。 `resultCode` 为我们在返回数据时传入的处理结果。 `data`为携带返回数据的 Intent。首先检查 `requestCode` 的值来判断数据来源。然后再通过 `resultCode` 的值来判断处理 结果。最后从 `data` 中取值。

```java
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    switch (requestCode) {
        case REQUEST_TARGET:
            if (RESULT_OK == resultCode) {
                String result = data.getStringExtra("data_result");
            }
            break;

        default:
            break;
    }
}
```

### Activity 的生命周期

#### 返回栈

Android 使用任务 (Task) 来管理 Activity ，一个任务就是一组存放在栈里的 Activity 的集合，这个栈也被称作返回栈 (BackStack)。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的 Activity ，它会在返回栈中入栈，并处于栈顶的位置。而每当我们按下返回键或调用 `finish()` 方法去销毁一个 Activity 时，处于栈顶的 Activity 会出栈，这时前一个入栈的 Activity 就会重新处于栈顶的位置。系统总是会显示处于栈顶的 Activity 给用户。

#### Activity 状态

- 运行状态： Activity 处于栈顶时的状态。
- 暂停状态： Activity 不处于栈顶但依然可见时的状态。
- 停止状态： Activity 不处于栈顶并完全不可见时的状态。
- 销毁状态： Activity 被移出返回栈之后的状态。

#### Activity 生命周期

- `onCreate(Bundle)` // Activity 第一次创建时调用。用于完成初始化操作。
- `onStrat()` // Activity 由不可见变为可见时调用。
- `onResume()` // Activity 准备和用户交互时调用。此时 Activity 一定处于栈顶并是运行状态。
- `onPause()` // 系统准备启动或恢复其他 Activity 时调用。
- `onStop()` // Activity 变为不可见时调用。
- `onDestroy()` // Activity 销毁之前调用，执行后 Activity 变为销毁状态。
- `onRestart()` // Activity 由停止状态变为运行状态之前调用。

![Activity 生命周期](https://developer.android.google.cn/images/activity_lifecycle.png "Activity Lifecycle")

#### Activity 被回收的处理

当一个 Activity 进入停止状态，是有可能被系统回收的。在 Activity 被系统回收后，再次返回该 Activity 时不会调用 `onRestart()` 方法，而是调用 `onCreate()` 方法再次创建。如此该 Activity 中的状态和暂存数据都会丢失。 要解决这个问题，可以重写 `onSaveInstanceState(Bundle)` 方法。该方法在 Activity 被回收之前一定会被调用。 `outState` 参数是一个 `android.os.Bundle` 类型，用来保存状态和临时数据。

```java
@Override
protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    String tempData = "some temp data";
    outState.putString("temp_string", tempData);
}
```

在 Activity 的 `onCreate(Bundle)` 方法中，带有一个 `Bundle` 类型参数 `savedInstanceState` 。这个参数就是通过 `onSaveInstanceState(Bundle)` 保存下来的数据。要恢复状态和暂存数据，在其中取出相应数据即可。

```java
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    if (null != savedInstanceState) {
        String tempData = savedInstanceState.getString("temp_string");
    }
}
```

### Activity 的启动模式

Activity 的启动模式一共有4种，分别是 `standard` ， `singleTop` ， `singleTask` 和 `singleInstance` 。可以在 `AndroidManifest.xml` 中通过给 `<activity>` 标签指定 `android:launchMode` 属性来选择启动模式。

#### standard

是 Activity 的默认启动模式，不需要进行额外配置。使用 standard 模式，每当启动一个新的 Activity ，不管这个 Activity 是否已经在返回栈中存在，都会创建一个新的对象入栈，并处于栈顶的位置。

#### singleTop

使用 singleTop 模式，当启动一个新的 Activity 时，若有一个该 Activity 的对象在栈顶，则直接使用该对象。否则，新建一个该 Activity 的对象入栈。

```xml
<activity
    android:name=".SingleTopActivity"
    android:launchMode="singleTop">
</activity>
```

#### singleTask

使用 singleTask 模式，每次启动该 Activity 时系统首先会在返回栈中检查是否存在该 Activity 的对象，如果发现已经存在则直接使用该对象，并把在这个活动之上的所有 Activity 出栈。如果没有发现就会创建一个新的 Activity 对象入栈。

```xml
<activity
    android:name=".SingleTaskActivity"
    android:launchMode="singleTask">
</activity>
```

#### singleInstance

使用 singleInstance 模式，系统会启用一个新的返回栈来管理该 Activity 。不管是哪个应用程序来访问这个 Activity ，都共用同一个返回栈。

```xml
<activity
    android:name=".SingleInstanceActivity"
    android:launchMode="singleInstance">
</activity>
```

### 最佳实践

#### 判断当前在哪一个 Activity

可以创建 BaseActivity 并添加如下方法，并使所有 Activity 都继承该 BaseActivity 。该方法可以返回当前 Activity 类名的字符串。

```java
public class BaseActivity extends AppCompatActivity {
    protected String getCurrentActivityName() {
        return getClass().getSimpleName();
    }
}
```

#### 随时退出程序

在项目中创建一个 `ActivityCollector` 管理类。

```java
public class ActivityCollector {
    public static List<Activity> activities = new ArrayList<>();

    public static void addActivity(Activity activity) {
        activities.add(activity);
    }

    public static void removeActivity(Activity activity) {
        activities.remove(activity);
    }

    public static void finishAll() {
        for (Activity activity : activities) {
            if (!activity.isFinishing()) {
                activity.finish();
            }
        }
        activities.clear();
    }
}
```

在 `BaseActivity` 的添加如下代码：

```java
public class BaseActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityCollector.addActivity(this);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        ActivityCollector.removeActivity(this);
    }
}
```

经过以上处理，在想退出的地方直接调用 `ActivityCollector.finishAll()` 即可销毁所有 Activity ，退出程序。为了完全退出，还可以在销毁所有活动后添加结束进程的代码。

```java
android.os.Process.killProcess(android.os.Process.myPid());
```

#### 最佳启动 Activity 方法

标准的开启 Activity 方法中，当需要在 Activity 之间传递数据时，必须在当前和目标 Activity 分别存入和取出数据。这样不是很直接，又可能出现一些对接问题。我们可以在目标 Activity 添加一个静态方法来解决。

```java
public class TargetActivity extends BaseActivity {
    public static void actionStart(Context context, String data1, int data2) {
        Intent intent = new Intent(context, TargetActivity.class);
        intent.putExtra("data1", data1);
        intent.putExtra("data2", data2);
        context.startActivity(intent);
    }
}
```

这样，当前 Activity 调用 `actionStart()` 方法，需要传递哪些数据一目了然。

[↑目录](#index)

------

<h2 id="chap3">第3章 UI布局</h2>

Android 使用 `XML` 代码来编写界面。

### 常用控件

#### TextView

`TextView` 主要用于在界面上显示一段文本信息。

```xml
<TextView android:id="@+id/text_view"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:gravity="center"
    android:textSize="24sp"
    android:textColor="#00ff00"
    android:text="This is TextView" />
```

#### Button

`Button` 按钮，是程序用于和用户进行交互的一个重要控件。

```xml
<Button android:id="@+id/button"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Button" />
```

Button 中所有英文字母会自动转换为大写，可以添加 `android:textAllCaps="false"` 来禁用。

Button 还需要注册一个点击事件监听器才能响应点击事件。点击按钮时，会执行监听器中的 `onClick(View)` 方法。

```java
Button button = (Button) findViewById(R.id.button);
button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        // 在此处添加逻辑
    }
});
```

#### EditText

`EditText` 允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理。可以使用 `android:hint` 属性指定提示性的文本，当我们输入任何内容时，这段文本就会自动消失。

```xml
<EditText android:id="@+id/edit_text"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:maxLines="2"
    android:hint="Type something here" />
```

在程序中，可以通过 `getText()` 方法获取输入的文本。

```java
EditText editText = (EditText) findViewById(R.id.edit_text);
String inputText = editText.getText().toString();
```

#### ImageView

`ImageView` 是用来在界面上展示图片的一个控件。图片资源通常都是放在以 `drawable` 开头的目录下的。

```xml
<ImageView android:id="@+id/image_view"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:src="@ drawable/img_1"/>
```

在程序中，还可以使用代码动态设置 ImageView 的图片。

```java
ImageView imageView = (ImageView) findViewById(R.id.image_view);
imageView.setImageResource(R.drawable.img_2);
```

#### ProgressBar

`ProgressBar` 用于在界面上显示一个进度条，表示程序正在加载一些数据。

```xml
<ProgressBar android:id="@+id/progress_bar"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"/>
```

想要让进度条消失，可以设置 Android 控件的可见属性。可见性可以在控件属性中加入 `android:visibility` 进行指定，可选值有 3 种： `visible` ， `invisible` 和 `gone` 。 `visible` 是默认值，表示控件是可见的。 `invisible` 表示控件不可见，但是仍然占据原来的位置和大小。 `gone` 则表示控件不仅不可见，而且不再占用任何屏幕空间。如果想通过代码设置可见属性，需要使用 `setVisibility(int)` 方法。可传值为`View.VISIBLE` ， `View.INVISIBLE` 和 `View.GONE` 。

```java
ProgressBar progressBar = (ProgressBar) findViewById(R.id.progress_bar);
progressBar.setVisibility(View.GONE);
```

ProgressBar 还可以指定不同的样式。通过 `style` 属性可以将它指定成水平进度条，通过 `android:max` 属性给进度条设置一个最大值。

```xml
<ProgressBar android:id="@+id/progress_bar"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    style="?android:attr/progressBarStyleHorizontal"
    android:max="100"/>
```

在代码中，可以动态更改进度条的进度。

```java
ProgressBar progressBar = (ProgressBar) findViewById(R.id.progress_bar);
int newProgress = lastProgress + 10;
progressBar.setProgress(newProgress);
```

#### AlertDialog

`AlertDialog` 可以在当前的界面弹出一个对话框，置顶于所有界面元素之上，屏蔽其他控件的交互能力。 `AlertDialog` 一般用于提示一些非常重要的内容或者警告信息。

```java
AlertDialog.Builder dialog = new AlertDialog.Builder(Activity.this);
dialog.setTitle("This is Dialog");
dialog.setMessage("Something important.");
dialog.setCancelable(false);
dialog.setPositiveButton("OK", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        // 点击 OK 的逻辑
    }
});
dialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        // 点击 Cancel 的逻辑
    }
});
dialog.show();
```

想关闭对话框，可以调用 `dismiss()` 方法。

```java
dialog.dismiss();
```

#### ProgressDialog

`ProgressDialog` 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，提示用户耐心地等待。

```java
ProgressDialog progressDialog = new ProgressDialog(Activity.this);
progressDialog.setTitle("This is ProgressDialog");
progressDialog.setMessage("Loading...");
progressDialog.setCancelable(true);
progressDialog.show();
```

想关闭对话框，同样可以调用 `dismiss()` 方法。

```java
progressDialog.dismiss();
```

### 基本布局

布局是一种可用于放置很多控件的容器，它可以按照一定的规律调整内部控件的位置。除了放置控件外，布局的内部也可以放置布局。通过多层布局的嵌套，我们能够完成一些复杂界面的实现。

#### LinearLayout

`LinearLayout` 又称作线性布局，是一种非常常用的布局。这个布局会将它所包含的控件在线性方向上依次排列。可以通过 `android:orientation` 属性指定排列方向，可取值有 `vertical` 和 `horizontal`。

`LinearLayout` 中还有一个重要属性 `android:layout_weight` 。这个属性允许我们使用比例的方式来指定控件的大小。当使用了 `android:layout_weight` 属性后，控件在排列方向上的尺寸就不应该再由 `android:layout_width` 来决定，一般指定成 `0dp` 。系统会将 LinearLayout 下所有控件指定的 `layout_weight` 值相加，得到一个总值，然后每个控件所占大小的比例就是用该控件的 `layout_weight` 值除以刚才算出的总值。我们还可以指定部分控件的 `layout_weight` 值。

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Buttonandroid:id="@+id/button1"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="Button1"/>

    <Buttonandroid:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_weight="2"
        android:text="Button2"/>
</LinearLayout>
```

#### RelativeLayout

`RelativeLayout` 可以通过相对定位的方式让控件出现在布局的任何位置。有如下控制属性:

- `android:layout_alignParentLeft` // 和父布局左对齐
- `android:layout_alignParentTop` // 和父布局上对齐
- `android:layout_alignParentRight` // 和父布局右对齐
- `android:layout_alignParentBottom` // 和父布局下对齐
- `android:layout_centerInParent` // 在父布局中心
- `android:layout_toLeftOf` // 在指定控件之左
- `android:layout_above` // 在指定控件之上
- `android:layout_toRightOf` // 在指定控件之右
- `android:layout_below` // 在指定控件之下
- `android:layout_alignLeft` // 和指定控件左对齐
- `android:layout_alignTop` // 和指定控件上对齐
- `android:layout_alignRight` // 和指定控件右对齐
- `android:layout_alignBottom` // 和指定控件下对齐

#### FrameLayout

`FrameLayout` 是一个十分轻量化的布局，没有特定的定位方式，所有的控件都默认摆放在布局的左上角。我们可以使用 `layout_gravity` 属性来指定控件在布局中的对齐方式。

#### PercentFrameLayout 和 PercentRelativeLayout

百分比布局允许直接指定控件在布局中所占的百分比。百分比布局定义在 support 库当中，需要在项目的 `build.gradle` 中添加百分比布局库的依赖。

```groovy
compile 'com.android.support:percent:25.3.1'
```

百分比布局为 `FrameLayout` 和 `RelativeLayout` 进行了功能扩展，使用 `app:layout_widthPercent` 属性可将控件的宽度指定为布局的百分比，使用 `app:layout_heightPercent` 属性可将控件的高度指定为布局的百分比。

### 自定义控件

所用的所有控件都是直接或间接继承自 `View` 的，所用的所有布局都是直接或间接继承自 `ViewGroup` 的。系统自带的控件不能满足我们的需求时，我们可以利用继承结构来创建自定义控件。

我们可以通过 `include` 语句将其他布局引入当前布局。

创建自定义控件时，要使自定义控件的类继承自控件 layout 的最外层布局，并重写构造方法。在构造方法中要借助 `LayoutInflater` 对标题栏布局进行动态加载，并可以进行注册监听器等操作。这样，就可以在其他布局中使用这个控件了。

### ListView

`ListView` 允许用户通过上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕。

```xml
<ListView android:id="@+id/list_view"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
```

`ListView` 需要使用适配器来填充数据。按照以下步骤使用 `ListView` ：

1. 定义实体类

    使用 `ListView` ，首先要定义一个实体类，作为 `ListView` 适配器的适配类型。

2. 定义条目布局

    需要为 `ListView` 的子项指定一个自定义的布局。

3. 创建适配器

    接下来需要创建一个自定义的适配器，继承自 `ArrayAdapter` ，并将泛型指定为之前定义的实体类。

    自定义适配器重写了父类的一组构造函数，用于将 `context` ， `ListView` 子项布局 id 和数据传递进来。

    还需要新建一个内部类 `ViewHolder` ，用于对条目控件的对象进行缓存。

    另外又重写了 `getView()` 方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。首先通过 `getItem()` 方法得到当前项的实例，然后在 `getView()` 方法中先进行判断，如果 `convertView` 为 `null` ，则加载布局，否则直接对 `convertView` 进行重用。

    加载布局时，首先使用 `LayoutInflater.inflate()` 来加载我们传入的布局。这里 `inflate()` 方法的第三个参数传 `false` ，表示只让在父布局中声明的 `layout` 属性生效，但不会为这个 `View` 添加父布局。因为一旦 `View` 有了父布局之后，它就不能再添加到 `ListView` 中了。接下来创建一个 `ViewHolder对象` ，并将控件的 对象都存放在这个 `ViewHolder对象` 里。然后调用 `View` 的 `setTag()` 方法，将 `ViewHolder对象` 存储在 `View` 中。

    重用 `ViewHolder` 时，调用 `View` 的 `getTag()` 方法，把 `ViewHolder` 重新取出。这样所有控件的 对象都缓存在 `ViewHolder` 里，避免每次都通过 `findViewById()` 方法获取控件 对象。

    最后，将数据 对象中的数据赋到 `ViewHolder` 中缓存的相应的控件上。

4. 实例化适配器

    在 Activity 中新建适配器的对象，并通过 `setAdapter()` 方法将其传递给 `ListView` 。

5. 添加点击事件

    在 Activity 中使用 `setOnItemClickListener()` 方法为 `ListView` 注册监听器。当用户点击了 ListView 中的一个子项时，就会回调 `onItemClick()` 方法。在这个方法中可以通过position参数判断出用户点击的是哪一个子项，然后执行相应逻辑。

### RecyclerView

`RecyclerView` 是一个增强版的 `ListView` ，不仅可以实现和 ListView 同样的效果，还优化了 ListView 中存在的各种不足之处。

#### 基本使用

`RecyclerView` 定义在 support 库当中。需要在项目的 `build.gradle` 中添加相应的依赖库。

```groovy
compile 'com.android.support:recyclerview-v7: 25.3.1'
```

`RecyclerView` 使用方法如下：

1. 在布局中添加 `RecyclerView`

    ```xml
    <android.support.v7.widget.RecyclerView
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
    ```

2. 定义实体类

    定义实体类，作为 `RecyclerView` 适配器的数据实体类型。

3. 定义条目布局

    为 `RecyclerView` 的子项指定自定义的布局。

4. 创建适配器

    新建适配器类，继承自 `RecyclerView.Adapter` 。

    根据定义的条目布局在适配器类内定义 ViewHolder 内部类，继承自 `RecyclerView.ViewHoler` 并重写构造方法。 ViewHolder 的构造方法中传入一个 `View` 参数，这个参数通常就是 RecyclerView 条目最外层布局，这样我们就可以通过 `findViewById()` 方法来获取到布局中的控件 对象。

    在适配器中传入数据源。可以通过添加带数据参数构造方法将数据传入。

    重写适配器的 `onCreateViewHolder(ViewGroup, int)` ， `onBindViewHolder(ViewHolder, int)` 和 `getItemCount()` 方法。 `onCreateViewHolder()` 方法用于创建 ViewHolder 对象。在这个方法中通过 `LayoutInflater` 加载布局，然后构造一个 ViewHolder 对象并返回。 `onBindViewHolder()` 方法用于对 RecyclerView 条目的数据进行赋值，会在每个条目被滚动到屏幕内的时候执行，可以通过 `position` 参数从数据源得到当前项数据，然后再将数据设置到 `ViewHolder` 的相应控件当中。 `getItemCount()` 用于返回条目的总数。

    除此之外，还可以重写 `getItemViewType(int)` 方法，这个方法用于多条目类型的 RecyclerView 。根据 `position` 参数判断当前条目类型并返回，这样在 `onCreateViewHolder()` 方法时就可以根据 `viewType` 参数来对不同类型的条目分别创建 ViewHolder 。

5. 实例化适配器

    `RecyclerView` 需要 `LayoutManager` 和 `Adapter` 才能正常工作。

    ```java
    RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
    LinearLayoutManager layoutManager = new LinearLayoutManager(context);
    MyAdapter adapter = new MyAdapter(data);
    recyclerView.setLayoutManager(layoutManager);
    recyclerView.setAdapter(adapter);
    ```

#### 横向滚动

在将 `LayoutManager` 赋给 RecyclerView 之前调用 `setOrientation(int)` 并传值 `LinearLayoutManager.HORIZONTAL` 即可实现横向滚动。

```java
RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
LinearLayoutManager layoutManager = new LinearLayoutManager(context);
layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
recyclerView.setLayoutManager(layoutManager);
```

#### 瀑布流

使用 `StaggeredGridLayoutManager` 作为 `LayoutManager` 可以实现瀑布流效果。 `StaggeredGridLayoutManager` 的构造方法接收两个参数，第一个参数用于指定布局的列数，第二个参数用于指定布局的排列方向。

```java
RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_ view);
StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);
recyclerView.setLayoutManager(layoutManager);
```

### Nine-Patch图片

`Nine-Patch` 图片是一种被特殊处理过的 `png` 图片，能够指定哪些区域可以被拉伸、哪些区域不可以。

在 Android sdk 目录下有一个 `tools` 文件夹，在这个文件夹中找到 `draw9patch.bat` 文件。双击打开，在导航栏点击 `File` → `Open9-patch` 将 `png` 图片加载进来。我们可以在图片的边框绘制小黑点，上边框和左边框绘制的部分表示图片可拉伸的区域，下边框和右边框绘制的部分表示放置内容的区域。使用鼠标在图片的边缘拖动可以绘制，按住 `Shift` 键拖动可以进行擦除。最后点击导航栏 `File` → `Save9-patch` 保存绘制好的图片，此时的文件后缀名是 `.9.png` 。

[↑目录](#index)

------

<h2 id="chap4">第4章 Fragment</h2>

`Fragment` 是一种可以嵌入 Activity 中的 UI 片段，它能让程序更加合理和充分地利用大屏幕的空间。

### 使用 Fragment

#### 简单用法

1. 创建布局文件

2. 新建 Fragment 类继承自 `android.support.v4.app.Fragment`

3. 重写 `onCreateView(LayoutInflater, ViewGroup, Bundle)` 加载布局

    ```java
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle
            savedInstanceState) {
        View view = inflater.inflate(R.layout.right_fragment, container, false);
        return view;
    }
    ```

4. 在 Activity 布局中添加 Fragment

    ```xml
    <fragment android:id="@+id/fragment"
        android:name="com.example.fragment.TestFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
    ```

#### 动态添加

1. 创建布局文件

2. 新建 Fragment 类继承自 `android.support.v4.app.Fragment`

3. 重写 `onCreateView(LayoutInflater, ViewGroup, Bundle)` 加载布局

    ```java
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle
            savedInstanceState) {
        View view = inflater.inflate(R.layout.right_fragment, container, false);
        return view;
    }
    ```

4. 在 Activity 的 Layout 中添加布局控件以放置 Fragment

    ```xml
    <FrameLayout android:id="@+id/fragment_container"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
    ```

5. 在 Activity 中动态替换 Fragment

    1. 创建待添加的 `Fragment` 对象。
    2. Activity 中通过调用 `getSupportFragmentManager()` 方法获取 `FragmentManager`
    3. 调用 `beginTransaction()` 方法开启一个事务。
    4. 向容器内添加或替换 `Fragment` ，一般使用 `replace()` 方法实现，需要传入容器的 id 和待添加的 Fragment 对象。
    5. 调用 `commit()` 方法提交事务。

    ```java
    TestFragment fragment = new TestFragment(context);
    FragmentManager fragmentManager = getSupportFragmentManager();
    FragmentTransaction transaction = fragmentManager.beginTransaction();
    transaction.replace(R.id.fragment_container, fragment);
    transaction.commit();
    ```

#### 使用限定符

在工程的 `res` 目录下新建 `layout-large` 文件夹。其中 `large` 是一个限定符，屏幕被认为是 `large` 的设备就会自动加载 `layout-large` 文件夹下的布局，而其他的设备则还加载 `layout` 文件夹下的布局。 Android 中一些常见的限定符如下：

- 屏幕大小
  - small
  - medium
  - large
  - xlarge

- 分辨率
  - ldpi
  - mdpi
  - hdpi
  - xhdpi
  - xxhdpi

- 方向
  - land
  - port

通过在工程的 `res` 目录下新建 `layout-sw***dp` 文件夹，我们可以指定最小宽度限定符。最小宽度限定符允许我们对屏幕的宽度指定一个最小值（以 `dp` 为单位），然后以这个最小值为临界点，屏幕宽度大于这个值的设备加载该文件夹内的布局，屏幕宽度小于这个值的设备加载其他文件夹内的布局。

### 模拟返回栈

`FragmentTransaction` 中提供了一个 `addToBackStack(String)` 方法，可以用于将一个事务添加到返回栈中。

```java
TestFragment fragment = new TestFragment(context);
FragmentManager fragmentManager = getSupportFragmentManager();
FragmentTransaction transaction = fragmentManager.beginTransaction();
transaction.addToBackStack(null);
transaction.replace(R.id.fragment_container, fragment);
transaction.commit();
```

### Fragment 和 Activity 间通信

调用 `FragmentManager` 的 `findFragmentById()` 方法，可以在 Activity 中得到相应 `Fragment` 的对象，然后就能调用 Fragment 里的方法。

```java
FragmentManager fragmentManager = getSupportFragmentManager();
TestFragment fragment = (TestFragment) fragmentManager.findFragmentById(R.id.fragment_container);
```

在 `Fragment` 中可以通过调用 `getActivity()` 方法来得到和当前 Fragment 相关联的 Activity 对象。

```java
MainActivity activity = (MainActivity) getActivity();
```

在一个 Fragment 中得到与它相关联的Activity ，然后再通过这个 Activity 去获取另外一个 Fragment 的对象，这样就可以实现不同 Fragment 之间的通信功能。

### Fragment 的生命周期

`Fragment` 拥有和 `Activity` 相似的生命周期。

#### Fragment 状态

- 运行状态： Fragment 是可见的，并且其所关联的 Activity 正处于运行状态。
- 暂停状态： Activity 进入暂停状态时，与其相关联的可见 Fragment 会进入暂停状态。
- 停止状态： Activity 进入停止状态时，与其相关联的 Fragment 会进入停止状态。通过调用 `FragmentTransaction` 的 `remove()` ， `replace()` 方法将 Fragment 从 Activity 中移除，但在事务提交之前调用 `addToBackStack()` 方法， Fragment 也会进入停止状态。进入停止状态的 Fragment 对用户来说完全不可见。
- 销毁状态： 当 Activity 被销毁时，与其相关联的 Fragment 会进入销毁状态。通过调用 `FragmentTransaction` 的 `remove()` ， `replace()` 方法将 Fragment 从 Activity 中移除，但在事务提交之前并没有调用 `addToBackStack()` 方法， Fragment 也会进入销毁状态。

#### Fragment 生命周期

- `onAttach(Activity)` // Fragment 和 Activity 建立关联时调用。
- `onCreate(Bundle)` // Fragment 第一次创建时调用。用于完成初始化操作。
- `onCreateView(LayoutInflater, ViewGroup, Bundle)` // Fragment 创建 View （加载布局）时调用。
- `onActivityCreated(Bundle)` // 确保与 Fragment 相关联的 Activity 已经创建完毕时调用。
- `onStart()` // Fragment 由不可见变为可见时调用。
- `onResume()` // Fragment 准备和用户交互时调用。此时其关联的 Activity 一定处于栈顶并是运行状态。
- `onPause()` // Fragment 关联的 Activity 进入暂停状态， Fragment 暂停和用户交互时调用。
- `onStop()` // Fragment 变为不可见时调用。
- `onDestroyView()` // 当与 Fragment 关联的 View 被移除时调用。
- `onDestroy()` // Fragment 销毁之前调用，执行后 Fragment 变为销毁状态。
- `onDetach()` // Fragment 和 Activity 解除关联时调用。

![Fragment 生命周期](https://developer.android.google.cn/images/fragment_lifecycle.png "Fragment Lifecycle")

[↑目录](#index)

------

<h2 id="chap5">第5章 BroadCast</h2>

Android 提供了一套完整的 API，允许应用程序发送和接收 BroadCast 。发送 BroadCast 的方法是借助 `Intent` 。而接收 BroadCast 则需要通过 `BroadcastReceiver` 。

### 广播机制

Android 中的每个应用程序都可以对感兴趣的 BroadCast 进行注册， 这样该程序就只会接收到注册类型的 BroadCast 内容。

### 接收广播

接收 BroadCast 需要注册 `BroadcastReceiver` 。

<h4 id="dyn_reg">动态注册</h2>

1. 定义 BroadcastReceiver

    定义一个 `BroadcastReceiver` 类，继承自 `android.content.BroadcastReceiver` 并重写其中的 `onReceive(Context, Intent)` 方法添加逻辑。每当收到相应 BroadCast 的时候就会执行 `onReceive(Context, Intent)` 方法。不要在 `onReceive(Context, Intent)` 方法中添加过多的逻辑或进行任何耗时操作，因为在 BroadcastReceiver 中不允许开启线程，当 `onReceive(Context, Intent)` 方法运行较长时间而没有结束时，程序会报错。

2. 创建 IntentFilter 对象

    在需要接收 BroadCast 处创建一个 `IntentFilter` 的对象，并调用 `addAction(String)` 方法添加 action 。此 action 就是程序想要接收的 BroadCast 类型。还可以调用 `setPriority(int)` 方法声明优先级。

3. 创建 BroadcastReceiver 对象

    创建刚才自定义的 BroadcastReceiver 的对象。

4. 注册 BroadcastReceiver

    调用 `registerReceiver(BroadcastReceiver, IntentFilter)` 方法对 BroadcastReceiver 进行注册。

5. 取消注册 BroadcastReceiver

    动态注册的 BroadcastReceiver 一定要在适当的位置取消注册。 调用 `unregisterReceiver(BroadcastReceiver)` 方法即可实现。取消注册操作一般在 `onDestroy()` 方法中进行。

6. 添加权限

    如果程序需要进行用户比较敏感的操作，就必须在打开 `AndroidManifest. xml` 文件中声明权限才可以，否则程序将会直接崩溃。

#### 静态注册

动态注册的 BroadcastReceiver 可以自由地注册与注销，但是它必须在程序启动后才能接收 Broadcast 。而静态注册的方式可以让程序在未启动的情况下就能接收到 BroadCast 。静态注册就是在 `AndroidManifest.xml` 中注册。

1. 定义 BroadcastReceiver

    同[动态注册](#dyn_reg)。

2. 注册 BroadcastReceiver

    在 `<application>` 标签内添加新的标签 `<receiver>` 来注册静态的 BroadcastReceiver 。在 `<receiver>` 标签中添加 `android:name` 属性来指定注册的 BroadcastReceiver 类名， `enabled` 属性指定是否启用这个 BroadcastReceiver ， `exported` 属性指定是否允许这个 BroadcastReceiver 接收本程序以外的 Broadcast 。在 `<receiver>` 标签内添加新的标签 `<intent-filter>` ，并在标签内添加新的标签 `<action>` 。每一个 `<action>` 标签对应一个 BroadCast 的 action ，在标签中添加 `android:name` 属性指定想要接收的 BroadCast 类型。 `<intent-filter>` 标签还可以添加 `android:priority` 属性来声明优先级。

3. 添加权限

    在 `AndroidManifest. xml` 文件中声明相应权限。

### 发送广播

<h4 id="snd_nor_bc">发送标准广播</h2>

标准广播（Normal broadcasts）是一种异步执行的 BroadCast 。在 BroadCast 发出之后，所有的 BroadCastReceiver 会在同一时刻接收到这条 BroadCast 。它们之间没有任何先后顺序可言，它是无法被截断的。

1. 构造 `Intent` 对象

    新建 `Intent` 对象，并调用 `setAction(String)` 方法添加 action 。还可以按需求在 Intent 对象中暂存数据。

2. 发送 BroadCast

    调用 `sendBroadcast(Intent)` 方法发送 BroadCast 。该方法在 `android.content.Context` 中。

#### 发送有序广播

有序广播（Ordered broadcasts）是一种同步执行的 BroadCast 。在 BroadCast 发出之后，同一时刻只会有一个 BroadCastReceiver 能够收到这条 BroadCast 。当这个 BroadCastReceiver 中的逻辑执行完毕后， BroadCast 才会继续传递。此时 BroadCastReceiver 是有先后顺序的，优先级高的 BroadCastReceiver 可以先收到 BroadCast ，并且前面的 BroadCastReceiver 还可以截断正在传递的 BroadCast ，使后面的 BroadCastReceiver 无法收到 BroadCast 。

1. 构造 `Intent` 对象

    同[发送标准广播](#snd_nor_bc)。

2. 发送 BroadCast

    调用 `sendOrderedBroadcast(Intent, String)` 方法发送 BroadCast 。该方法在 `android.content.Context` 中。 `String` 类型参数是一个与权限相关的字符串，可以传入 `null` 。

3. 截断 BroadCast

    在 `BroadCastReceiver` 中的 `onReceive(Context, Intent)` 方法中调用 `abortBroadcast()` 方法即可截断 BroadCast 。

### 本地广播

本地广播（Local Broadcast）发出的 BroadCast 只能在应用程序内部传递，并且 BroadCastReceiver 也只能接收来自本应用程序发出的 BroadCast 。本地广播相对全局广播有以下优势：

- 可以明确知道正在发送的广播不会离开程序，不必担心机密数据泄漏。
- 其他程序无法将广播发送到程序内部，不必担心安全漏洞的隐患。
- 发送本地广播比发送系统全局广播更加高效。

#### 发送本地广播

1. 构造 `Intent` 对象

    同[发送标准广播](#snd_nor_bc)。

2. 发送 BroadCast

    调用 `LocalBroadcastManager.getInstance(Context)` 获取 LocalBroadcastManager 对象。然后调用其中的 `sendBroadcast(Intent)` 方法发送 BroadCast 。

#### 接收本地广播

本地广播无法通过静态注册的方式来接收，只能在代码中动态注册。

1. 定义 BroadcastReceiver

    同[动态注册](#dyn_reg)。

2. 创建 IntentFilter 对象

    同[动态注册](#dyn_reg)。

3. 创建 BroadcastReceiver 对象

    同[动态注册](#dyn_reg)。

4. 注册 BroadcastReceiver

    调用 `LocalBroadcastManager.getInstance(Context)` 获取 LocalBroadcastManager 对象。然后调用其中的 `registerReceiver(BroadcastReceiver, IntentFilter)` 方法注册 BroadcastReceiver 。

5. 取消注册 BroadcastReceiver

    调用 LocalBroadcastManager 对象的 `unRegisterReceiver(BroadcastReceiver)` 方法取消注册 BroadcastReceiver 。

[↑目录](#index)

------

<h2 id="chap6">第6章 数据持久化</h2>

数据持久化是指将内存中的瞬时数据保存到存储设备中，保证即使在手机或电脑关机的情况下，这些数据仍然不会丢失。

### 文件存储

文件存储是 Android 中最基本的数据存储方式，它不对存储的内容进行任何的格式化处理。因而适合存储一些简单的文本数据或二进制数据。

#### 写入到文件

`Context` 类中提供了一个 `openFileOutput(String, int)` 方法，用于将数据存储到指定的文件中。该方法返回一个 `FileOutputStream` 对象。 `String` 参数是不包含路径的文件名，在文件创建的时候将使用这个文件名。文件默认存储到 `/data/data/<package-name>/files/` 目录下。 `int` 参数是文件的操作模式，有两种可选，`MODE_PRIVATE` 和 `MODE_APPEND` ，其他模式已经废弃。 `MODE_PRIVATE` 是默认操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原文件中的内容。而 `MODE_APPEND` 则表示如果该文件已存在，就往文件里面追加内容，不存在就创建新文件。

```java
try {
    FileOutputStream out = openFileOutput("data", Context.MODE_PRIVATE);
    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out));
    writer.write(data);

} catch (IOException e) {
    e.printStackTrace();

} finally {
    try {
        if (null != writer) {
            writer.close();
        }

    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

#### 从文件读取

`Context` 类中提供了一个 `openFileInput(String)` 方法，用于从文件中读取数据。该方法回一个 `FileInputStream` 对象。 `String` 参数是要读取的文件名，系统会自动到 `/data/data/<package-name>/files/` 目录下加载这个文件。

```java
try {
    FileInputStream in = openFileInput("data");
    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
    String line = "";
    while (null != (line = reader.readLine())) {
        content.append(line);
    }

} catch (IOException e) {
    e.printStackTrace();

} finally {
    if (null != reader) {
        try {
            reader.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### SharedPerferences 存储

`SharedPreferences` 使用键值对的方式来存储数据。

#### 获取 SharedPerferences 对象

使用 `SharedPreferences` ，需要获取到 `SharedPreferences` 对象。

- `Context` 中 `getSharedPreferences(String, int)` 方法

    `String` 参数用于指定 SharedPreferences 的文件名，如果文件不存在则会创建一个。 SharedPreferences 文件存放在 `/data/data/<package-name>/shared_prefs/` 目录下。 `int` 参数用于指定操作模式，目前只有 `MODE_PRIVATE` 这一种模式可选，表示只有当前的应用程序可以对这个 SharedPreferences 文件进行读写。其他模式已经废弃。

- `Activity` 中 `getPreferences(int)` 方法

    `int` 参数用于指定操作模式。该方法会自动将当前 Activity 的类名作为 SharedPreferences 的文件名。

- `PreferenceManager.getDefaultSharedPreferences(Context)` 静态方法

    `Context` 参数为当前程序上下文。该方法自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。

#### 写入到 SharedPerferences

1. 调用 `SharedPreferences` 对象的 `edit()` 方法获取 `SharedPreferences.Editor` 对象。
2. 向 `SharedPreferences.Editor` 对象中添加数据。可以通过以下方法。第一个参数均为 key ，第二个参数为 value 。

    - `putString(String, String)`
    - `putStringSet(String, Set<String>)`
    - `putInt(String, int)`
    - `putLong(String, long)`
    - `putFloat(String, float)`
    - `putBoolean(String, boolean)`

3. 调用 `apply()` 方法将添加的数据提交。

#### 从 SharedPerferences 读取

`SharedPreferences` 对象中提供了一系列的读取方法，用于对存储的数据进行读取。这些方法第一个参数均为 key ，第二个参数为 defValue ，默认值。表示当传入的键找不到对应的值时的返回值。

- `getString(String, String)`
- `getStringSet(String, String<String>)`
- `getInt(String, int)`
- `getLong(String, long)`
- `getFloat(String, float)`
- `getBoolean(String, boolean)`

### SQLite 数据库存储

`SQLite` 是一款轻量级的关系型数据库。它的运算速度非常快，占用资源很少，通常只需要几百 KB 的内存就足够了，因而特别适合在移动设备上使用。

Android 提供了一个 `SQLiteOpenHelper` 帮助类对数据库进行创建和升级。 `SQLiteOpenHelper` 是一个抽象类，需要创建一个自己的帮助类去继承它。 `SQLiteOpenHelper` 有两个构造方法可重写，一般使用 `SQLiteOpenHelper(Context, String, CursorFactory, int)` 。 `Context` 是当前程序上下文。 `String` 是数据库名。`CursorFactory` 允许我们在查询数据的时候返回一个自定义的 `Cursor` ，一般传入 `null` 。 `int` 是当前数据库的版本号，可用于对数据库进行升级操作。 `SQLiteOpenHelper` 中需要重写两个抽象方法 `onCreate(SQLiteDatabase)` 和 `onUpgrade(SQLiteDatabase, int, int)` ，在这两个方法中去实现创建和升级数据库的逻辑。

#### 创建数据库

创建 `SQLiteOpenHelper` 对象后，调用它的 `getReadableDatabase()` 或 `getWritableDatabase()` 方法即可创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则创建一个新的数据库），并返回一个 `SQLiteDatabase` 对象。不同的是，当数据库不可写入的时候（如磁盘空间已满）， `getReadableDatabase()` 方法返回的对象将以只读的方式去打开数据库，而 `getWritableDatabase()` 方法则将出现异常。数据库文件会存放在 `/data/data/<package-name>/databases/` 目录下。如果创建一个新的数据库，会执行重写的 `onCreate(SQLiteDatabase)` 方法。我们通常在这里处理创建表的逻辑。我们可以把 SQL 建表语句定义成一个字符串常量，然后在 `onCreate(SQLiteDatabase)` 方法中调用 `SQLiteDatabase` 对象的 `execSQL()` 方法去执行这条建表语句。

#### 升级数据库

当数据库已存在，而我们又想修改数据库结构时，我们可以使用 `onUpgrade(SQLiteDatabase, int, int)` 方法。在创建 `SQLiteOpenHelper` 对象时，版本号参数传一个比当前版本号大的值然后打开数据库，会执行 `onUpgrade(SQLiteDatabase, int, int)` 方法。我们通常在这里处理升级表的逻辑。 `SQLiteDatabase` 参数是可对数据库进行读写操作的对象。第一个 `int` 参数是旧的数据库版本。第二个 `int` 参数是新的数据库版本。我们可以把 SQL 升级语句定义成一个字符串常量，然后在 `onUpgrade(SQLiteDatabase, int, int)` 方法中根据数据库的新旧版本号调用 `SQLiteDatabase` 对象的 `execSQL()` 方法去执行这条升级语句。

#### 增

调用 `SQLiteOpenHelper` 的 `getReadableDatabase()` 或 `getWritableDatabase()` 方法会返回一个 `SQLiteDatabase` 对象，其中提供了 `insert(String, String, ContentValues)` 方法用于添加数据。第一个 `String` 参数是要添加数据的表名。第二个 `String` 参数用于在未指定添加数据的情况下给某些可为空的列自动赋值 `NULL` ，一般直接传入 `null` 即可。 `ContentValues` 参数是一个 `ContentValues` 对象，它提供了一系列的方法重载用于向 `ContentValues` 中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。这些方法的第一个参数为表的列名，第二个参数为对应的数据。

- `put(String, Boolean)`
- `put(String, Byte)`
- `put(String, byte[])`
- `put(String, Double)`
- `put(String, Float)`
- `put(String, Integer)`
- `put(String, Long)`
- `put(String, Short)`
- `put(String, String)`

#### 删

`SQLiteDatabase` 对象提供了 `delete(String, String, String[])` 方法用于删除数据。 第一个 `String` 参数是要删除数据的表名。第二个 `String` 和第三个 `String[]` 参数用于约束删除某一行或某几行中的数据，不指定的话默认删除所有行。

#### 改

`SQLiteDatabase` 对象提供了 `update(String, ContentValues, String, String[])` 方法用于更新数据。 第一个 `String` 参数是要更新数据的表名。 `ContentValues` 参数是 `ContentValues` 对象，组装要更新数据。第三个 `String` 和第四个 `String[]` 参数用于约束更新某一行或某几行中的数据，不指定的话默认更新所有行。

#### 查

`SQLiteDatabase` 对象提供了 `query()` 方法用于查询数据。这个方法十分复杂，有四种重载，用的较多的是 `query(String, String[], String, String[], String, String, String)` 。这个方法有七个参数。第一个参数 `table` 指定查询的表名。 第二个参数 `columns` 指定查询的列名。第三个 `selection` 指定 where 的约束条件参数。第四个参数 `selectionArgs` 为 where 中的占位符提供具体的值。第五个参数 `groupBy` 指定需要 groupby 的列。第六个参数 `having` 对 groupby 后的结果进一步约束。第七个参数 `orderBy` 指定查询结果的排序方式。该方法返回一个 `Cursor` 对象，查询到的所有数据都将从这个对象中取出。

#### 使用 SQL 语句

`SQLiteDatabase` 对象提供了直接处理 SQL 语句的方法。增删改时可以使用 `execSQL()` 方法，查询时可以使用 `rawQuery()` 方法。

### LitePal 操作数据库

#### 配置 LitePal

#### LitePal 创建数据库

#### LitePal 升级数据库

#### LitePal 增

#### LitePal 删

#### LitePal 改

#### LitePal 查

[↑目录](#index)

------

<h2 id="chap7">第7章 Content Provider</h2>

### 运行时权限

#### 运行时权限申请

### ContentResolver

### 自定义 Content Provider

[↑目录](#index)

------

<h2 id="chap8">第8章 多媒体</h2>

[↑目录](#index)

<h2 id="chap9">第9章 网络</h2>

[↑目录](#index)

<h2 id="chap10">第10章 Service</h2>

[↑目录](#index)

<h2 id="chap11">第11章 定位</h2>

[↑目录](#index)

<h2 id="chap12">第12章 Material Design</h2>

[↑目录](#index)

<h2 id="chap13">第13章 高级技巧</h2>

[↑目录](#index)

<h2 id="chap14">第14章 欧酷天气</h2>

[↑目录](#index)

<h2 id="chap15">第15章 发布应用</h2>

[↑目录](#index)

<h2 id="git">Git 时间</h2>

### 安装 git

- Ubuntu

    `sudo apt-get install git-core`

- Windows

    `https://git-for-windows.github.io/`

安装完成后，你需要配置一下自己的身份。

```shell
git config --global user.name "your_name"
git config --global user.email "your_email"
```

### 创建代码仓库

仓库（Repository）是用于保存版本管理所需信息的地方。所有本地提交的代码都会提交到本地 Repository 中， 如果有需还可以再推送到远程 Repository 中。在项目目录下输入 `git init` 即可创建本地 Repository 。 Repository 创建完成后，会在目的根目录下生成一个隐藏的 `.git` 文件夹。如果想要删除本地 Repository ，只需要删除这个文件夹就行了。

### 提交本地代码

使用 `add` 和 `commit` 命令。 `add` 用于添加要提交的代码， `commit` 用于执行提交操作。

```shell
git add [file-name]
git add [directory-name]
git add .
```

`commit` 命令一定要添加 `-m` 参数来加上提交的描述信息，没有描述信息的提交被认为是不合法的。

```shell
git commit -m "[comment]"
```

### 忽略文件

### 查看修改文件

### 撤销未提交的修改

### 查看提交记录

[↑目录](#index)
