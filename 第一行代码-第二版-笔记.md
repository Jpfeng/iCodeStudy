# 第一行代码 Android 第2版

<h2 id="index">目录</h2>

- [第1章 开始](#chap1)
- [第2章 Activity](#chap2)
- [第3章 UI布局](#chap3)
- [第4章 Fragment](#chap4)
- [第5章 BroadCast](#chap5)
- [第6章 数据持久化](#chap6)
- [第7章 Content Provider](#chap7)
- [第8章 多媒体](#chap8)
- [第9章 网络](#chap9)
- [第10章 Service](#chap10)
- [第11章 定位](#chap11)
- [第12章 Material Design](#chap12)
- [第13章 高级技巧](#chap13)
- [第14章 酷欧天气](#chap14)
- [第15章 发布应用](#chap15)

------

<h2 id="chap1">第1章 开始</h2>

### Android 系统架构

| ·     | 架构         |
| :---: | ------------ |
| 顶层  | 应用层       |
| ↑     | 应用框架层   |
| ↑     | 系统运行库层 |
| 底层  | Linux内核层  |

### 搭建开发环境

安装 Android Studio → 配置 Android Studio → 创建项目 → 创建模拟器 → 运行项目

### 日志工具

Android 中提供了 Log 工具类 `android.util.Log` ，其中提供了5个方法用来输出不同级别的日志。

```java
Log.v(String tag, String msg); // 对应级别 verbose ，用来打印最琐碎的信息
Log.d(String tag, String msg); // 对应级别 debug ，用来打印调试信息
Log.i(String tag, String msg); // 对应级别 info ，用来打印比较重要的信息
Log.w(String tag, String msg); // 对应级别 warn ，用来打印警告信息
Log.e(String tag, String msg); // 对应级别 error ，用来打印程序错误
```

输出的日志会显示在 logcat 中。logcat 可以通过以下三种方式过滤日志。

- [过滤器](#filter.1)
- [日志级别控制](#filter.2)
- [关键字过滤](#filter.3)

<h4 id="filter.1">过滤器</h4>

有三种过滤器：'show only selected application', 'Firebase', 'No Filters'。除此之外，还可以使用 'Edit Filter Configuration' 自定义过滤器。

<h4 id="filter.2">日志级别控制</h4>

logcat中有5个级别，分别对应 Log 工具类中的5个级别。

<h4 id="filter.3">关键字过滤</h4>

关键字过滤支持正则表达式。

[↑目录](#index)

------

<h2 id="chap2">第2章 Activity</h2>

Activity 是一种可以包含用户界面的组件，主要用于和用户进行交互。

### 使用 Activity

创建 Activity → 创建 Layout 并加载 → 在 Manifest 中注册

### 使用 Toast

Android 中提供了 Toast 组件 `android.widget.Toast` ，可以通过静态方法 `makeText()` 进行创建。

```java
Toast.makeText(Context context, CharSequence text, @Duration int duration);
```

`makeText()` 方法需要3个参数， `context` 为上下文对象， `text` 为 Toast 显示的内容， `duration` 为 Toast 的持续时间，可取值为 `Toast.LENGTH_LONG` 和 `Toast.LENGTH_SHORT` 。

### 使用 Menu

新建 Menu 资源文件 → 重写 `OnCreateOptionsMenu()` 方法，通过 `MenuInflater.inflate()` 方法创建菜单 → 重写 `OnOptionsItemSelected()` 处理选择事件

### 销毁 Activity

使用 Activity 中的 `finish()` 方法。此方法效果等同于按下返回键。

### 使用 Intent

在 Activity 之间跳转需要使用 `android.content.Intent` 类。Intent大致可以分两种：**显式 Intent** 和**隐式 Intent** 。

#### 显式 Intent

显式 Intent 通过 `Intent(Context packageContext, Class<?> cls)` 来进行构造。 `packageContext` 参数传入当前应用的上下文对象， `cls` 参数传入目标 Activity 。然后，我们可以通过 Activity 中的 `startActivity(Intent intent)` 方法来启动目标 Activity。

```java
Intent intent = new Intent(context, TargetActivity.class);
startActivity(intent);
```

#### 隐式 Intent

隐式 Intent 并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的 `action` 和 `category` 等信息，然后交由系统去分析这个 Intent，并帮我们找出合适的活动去启动。通过在 `AndroidManifest.xml` 中的 `<activity>` 标签下配置 `<intent-filter>` 的内容， 可以指定当前 Activity 能够响应的 action 和 category。每个 Intent 中只能指定一个 action，但却能指定多个 category。

```xml
<activity android:name=".TargetActivity">
    <intent-filter>
        <action android:name="com.example.activitytest.ACTION_START"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <category android:name="com.example.activitytest.MY_CATEGORY">
    </intent-filter>
</activity>
```

接下来，我们就可以通过 `Intent(String action)` 来构造 Intent。

```java
Intent intent = new Intent("com.example.activitytest.ACTION_START");
intent.addCategory("com.example.activitytest.MY_CATEGORY");
startActivity(intent);
```

使用隐式 Intent，我们不仅可以启动自己程序内的 Activity， 还可以启动其他程序的 Activity。

```java
Intent intent = new Intent(Intent.ACTION_VIEW);
intent.setData(Uri.parse("http://www.bing.com"));
startActivity(intent);
```

`setData()` 接收一个 `Uri` 对象，主要用于指定当前 Intent 正在操作的数据，而这些数据通常都是以字符串的形式传入到 `Uri.parse()` 方法中解析产生的。与此对应，我们可以在`<intent-filter>` 标签中再配置一个 `<data>` 标签，用于更精确地指定当前 Activity 能够响应什么类型的数据。只有 `<data>` 标签中指定的内容和 Intent 中携带的 Data 完全一致时， 当前 Activity 才能够响应该 Intent。 `<data>` 标签中主要可以配置以下内容。

- android:scheme 用于指定数据的协议部分。
- android:host 用于指定数据的主机名部分。
- android:port 用于指定数据的端口部分。
- android:path 用于指定主机名和端口之后的部分。
- android:mimeType 用于指定可以处理的数据类型，允许使用通配符的方式进行指定。

### Activity 间的数据传递

Intent 可以在 Activity 之间传递数据。

#### 向下一个 Activity 传递数据

Intent 中提供了一系列 `putExtra()` 方法的重载。可以通过该方法将数据暂存在 Intent 中，在目标 Activity 中从 Intent 取出就可以了。

```java
// 当前 Activity
String data1 = "Hello Target Activity";
int data2 = 123;
boolean data3 = true;
Intent intent = new Intent(context, TargetActivity.class);
intent.putExtra("string_extra", data1);
intent.putExtra("int_extra", data2);
intent.putExtra("boolean_extra", data3);
startActivity(intent);
```

```java
// 目标 Activity
Intent intent = getIntent();
String data1 = intent.getStringExtra("string_extra");
int data2 = intent.getIntExtra("int_extra", DEFAULT_INT);
boolean data3 = intent.getBooleanExtra("boolean_extra", DEFAULT_BOOLEAN);
```

#### 返回数据给上一个 Activity 并接收

Activity 中有一个 `startActivityForResult(@RequiresPermission Intent intent, int requestCode)` 方法，这个方法期望在 Activity 销毁的时候能够返回一个结果。第一个参数为 `Intent` ，第二个参数是请求码，需要是唯一值，用于在回调中判断数据的来源。

```java
Intent intent = new Intent(context, TargetActivity.class);
startActivityForResult(intent, REQUEST_TARGET);
```

在目标 Activity 中，可以构造一个新的 Intent 暂存数据，然后调用 `setResult(int resultCode, Intent data)` 方法。第一个参数用于向上一个 Activity 返回处理结果，一般使用 `Activity.RESULT_OK` 或 `Activity.RESULT_CANCELED` 两个值，第二个参数把带有数据的 Intent 传递回去。最后调用 `finish()` 销毁 Activity。

```java
String data = "Hello Previous Activity";
Intent intent = new Intent();
intent.putExtra("data_result", data);
setResult(intent, RESULT_OK);
finish();
```

如果想要处理用户点击返回键时回传的数据，可以重写 `onBackPressed()` 方法。

在 TargetActivity 销毁后，会回调上一个 Activity 的 `onActivityResult(int requestCode, int resultCode, Intent data)` 方法。我们需要重写上一个 Activity 中的 `onActivityResult(int requestCode, int resultCode, Intent data)` 方法来接收回传数据。 `requestCode` 为我们在启动 TargetActivity 时传入的请求码。 `resultCode` 为我们在返回数据时传入的处理结果。 `data`为携带返回数据的 Intent。首先检查 `requestCode` 的值来判断数据来源。然后再通过 `resultCode` 的值来判断处理 结果。最后从 `data` 中取值。

```java
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    switch (requestCode) {
        case REQUEST_TARGET:
            if (RESULT_OK == resultCode) {
                String result = data.getStringExtra("data_result");
            }
            break;

        default:
            break;
    }
}
```

### Activity 的生命周期

#### 返回栈

Android 使用任务 (Task) 来管理 Activity ，一个任务就是一组存放在栈里的 Activity 的集合，这个栈也被称作返回栈 (BackStack)。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的 Activity ，它会在返回栈中入栈，并处于栈顶的位置。而每当我们按下返回键或调用 `finish()` 方法去销毁一个 Activity 时，处于栈顶的 Activity 会出栈，这时前一个入栈的 Activity 就会重新处于栈顶的位置。系统总是会显示处于栈顶的 Activity 给用户。

#### Activity 状态

- 运行状态： Activity 处于栈顶时的状态。
- 暂停状态： Activity 不处于栈顶但依然可见时的状态。
- 停止状态： Activity 不处于栈顶并完全不可见时的状态。
- 销毁状态： Activity 被移出返回栈之后的状态。

#### Activity 生命周期

- `onCreate(Bundle savedInstanceState)` // Activity 第一次创建时调用。用于完成初始化操作。
- `onStrat()` // Activity 由不可见变为可见时调用。
- `onResume()` // Activity 准备和用户交互时调用。此时 Activity 一定处于栈顶并是运行状态。
- `onPause()` // 系统准备启动或恢复其他 Activity 时调用。
- `onStop()` // Activity 变为不可见时调用。
- `onDestroy()` // Activity 销毁之前调用，执行后 Activity 变为销毁状态。
- `onRestart()` // Activity 由停止状态变为运行状态之前调用。

![Activity 生命周期](https://developer.android.google.cn/images/activity_lifecycle.png "Activity Lifecycle")

#### Activity 被回收的处理

当一个 Activity 进入停止状态，是有可能被系统回收的。在 Activity 被系统回收后，再次返回该 Activity 时不会调用 `onRestart()` 方法，而是调用 `onCreate()` 方法再次创建。如此该 Activity 中的状态和暂存数据都会丢失。 要解决这个问题，可以重写 `onSaveInstanceState(Bundle outState)` 方法。该方法在 Activity 被回收之前一定会被调用。 `outState` 参数是一个 `android.os.Bundle` 类型，用来保存状态和临时数据。

```java
@Override
protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    String tempData = "some temp data";
    outState.putString("temp_string", tempData);
}
```

在 Activity 的 `onCreate(@Nullable Bundle savedInstanceState)` 方法中，带有一个 `Bundle` 类型参数 `savedInstanceState` 。这个参数就是通过 `onSaveInstanceState(Bundle outState)` 保存下来的数据。要恢复状态和暂存数据，在其中取出相应数据即可。

```java
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    if (null != savedInstanceState) {
        String tempData = savedInstanceState.getString("temp_string");
    }
}
```

### Activity 的启动模式

Activity 的启动模式一共有4种，分别是 `standard` ， `singleTop` ， `singleTask` 和 `singleInstance` 。可以在 `AndroidManifest.xml` 中通过给 `<activity>` 标签指定 `android:launchMode` 属性来选择启动模式。

#### standard

是 Activity 的默认启动模式，不需要进行额外配置。使用 standard 模式，每当启动一个新的 Activity ，不管这个 Activity 是否已经在返回栈中存在，都会创建一个新的实例入栈，并处于栈顶的位置。

#### singleTop

使用 singleTop 模式，当启动一个新的 Activity 时，若有一个该 Activity 的实例在栈顶，则直接使用该实例。否则，新建一个该 Activity 的实例入栈。

```xml
<activity
    android:name=".SingleTopActivity"
    android:launchMode="singleTop">
</activity>
```

#### singleTask

使用 singleTask 模式，每次启动该 Activity 时系统首先会在返回栈中检查是否存在该 Activity 的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有 Activity 出栈。如果没有发现就会创建一个新的 Activity 实例入栈。

```xml
<activity
    android:name=".SingleTaskActivity"
    android:launchMode="singleTask">
</activity>
```

#### singleInstance

使用 singleInstance 模式，系统会启用一个新的返回栈来管理该 Activity 。不管是哪个应用程序来访问这个 Activity ，都共用同一个返回栈。

```xml
<activity
    android:name=".SingleInstanceActivity"
    android:launchMode="singleInstance">
</activity>
```

### 最佳实践

#### 判断当前在哪一个 Activity

可以创建 BaseActivity 并添加如下方法，并使所有 Activity 都继承该 BaseActivity 。该方法可以返回当前 Activity 类名的字符串。

```java
public class BaseActivity extends AppCompatActivity {
    protected String getCurrentActivityName() {
        return getClass().getSimpleName();
    }
}
```

#### 随时退出程序

在项目中创建一个 `ActivityCollector` 管理类。

```java
public class ActivityCollector {
    public static List<Activity> activities = new ArrayList<>();

    public static void addActivity(Activity activity) {
        activities.add(activity);
    }

    public static void removeActivity(Activity activity) {
        activities.remove(activity);
    }

    public static void finishAll() {
        for (Activity activity : activities) {
            if (!activity.isFinishing()) {
                activity.finish();
            }
        }
        activities.clear();
    }
}
```

在 `BaseActivity` 的添加如下代码：

```java
public class BaseActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityCollector.addActivity(this);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        ActivityCollector.removeActivity(this);
    }
}
```

经过以上处理，在想退出的地方直接调用 `ActivityCollector.finishAll()` 即可销毁所有 Activity ，退出程序。为了完全退出，还可以在销毁所有活动后添加结束进程的代码。

```java
android.os.Process.killProcess(android.os.Process.myPid());
```

#### 最佳启动 Activity 方法

标准的开启 Activity 方法中，当需要在 Activity 之间传递数据时，必须在当前和目标 Activity 分别存入和取出数据。这样不是很直接，又可能出现一些对接问题。我们可以在目标 Activity 添加一个静态方法来解决。

```java
public class TargetActivity extends BaseActivity {
    public static void actionStart(Context context, String data1, int data2) {
        Intent intent = new Intent(context, TargetActivity.class);
        intent.putExtra("data1", data1);
        intent.putExtra("data2", data2);
        context.startActivity(intent);
    }
}
```

这样，当前 Activity 调用 `actionStart()` 方法，需要传递哪些数据一目了然。

[↑目录](#index)

------

<h2 id="chap3">第3章 UI布局</h2>

Android 使用 `XML` 代码来编写界面。

### 常用控件

#### TextView

`TextView` 主要用于在界面上显示一段文本信息。

```xml
<TextView android:id="@+id/text_view"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:gravity="center"
    android:textSize="24sp"
    android:textColor="#00ff00"
    android:text="This is TextView" />
```

#### Button

`Button` 按钮，是程序用于和用户进行交互的一个重要控件。

```xml
<Button android:id="@+id/button"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Button" />
```

Button 中所有英文字母会自动转换为大写，可以添加 `android:textAllCaps="false"` 来禁用。

Button 还需要注册一个点击事件监听器才能响应点击事件。点击按钮时，会执行监听器中的 `onClick(View v)` 方法。

```java
Button button = (Button) findViewById(R.id.button);
button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        // 在此处添加逻辑
    }
});
```

#### EditText

`EditText` 允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理。可以使用 `android:hint` 属性指定提示性的文本，当我们输入任何内容时，这段文本就会自动消失。

```xml
<EditText android:id="@+id/edit_text"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:maxLines="2"
    android:hint="Type something here" />
```

在程序中，可以通过 `getText()` 方法获取输入的文本。

```java
EditText editText = (EditText) findViewById(R.id.edit_text);
String inputText = editText.getText().toString();
```

#### ImageView

`ImageView` 是用来在界面上展示图片的一个控件。图片资源通常都是放在以 `drawable` 开头的目录下的。

```xml
<ImageView android:id="@+id/image_view"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:src="@ drawable/img_1"/>
```

在程序中，还可以使用代码动态设置 ImageView 的图片。

```java
ImageView imageView = (ImageView) findViewById(R.id.image_view);
imageView.setImageResource(R.drawable.img_2);
```

#### ProgressBar

`ProgressBar` 用于在界面上显示一个进度条，表示程序正在加载一些数据。

```xml
<ProgressBar android:id="@+id/progress_bar"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"/>
```

想要让进度条消失，可以设置 Android 控件的可见属性。可见性可以在控件属性中加入 `android:visibility` 进行指定，可选值有 3 种： `visible` ， `invisible` 和 `gone` 。 `visible` 是默认值，表示控件是可见的。 `invisible` 表示控件不可见，但是仍然占据原来的位置和大小。 `gone` 则表示控件不仅不可见，而且不再占用任何屏幕空间。如果想通过代码设置可见属性，需要使用 `setVisibility(int visibility)` 方法。可传值为`View.VISIBLE` ， `View.INVISIBLE` 和 `View.GONE` 。

```java
ProgressBar progressBar = (ProgressBar) findViewById(R.id.progress_bar);
progressBar.setVisibility(View.GONE);
```

ProgressBar 还可以指定不同的样式。通过 `style` 属性可以将它指定成水平进度条，通过 `android:max` 属性给进度条设置一个最大值。

```xml
<ProgressBar android:id="@+id/progress_bar"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    style="?android:attr/progressBarStyleHorizontal"
    android:max="100"/>
```

在代码中，可以动态更改进度条的进度。

```java
ProgressBar progressBar = (ProgressBar) findViewById(R.id.progress_bar);
int newProgress = lastProgress + 10;
progressBar.setProgress(newProgress);
```

#### AlertDialog

`AlertDialog` 可以在当前的界面弹出一个对话框，置顶于所有界面元素之上，屏蔽其他控件的交互能力。 `AlertDialog` 一般用于提示一些非常重要的内容或者警告信息。

```java
AlertDialog.Builder dialog = new AlertDialog.Builder(Activity.this);
dialog.setTitle("This is Dialog");
dialog.setMessage("Something important.");
dialog.setCancelable(false);
dialog.setPositiveButton("OK", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        // 点击 OK 的逻辑
    }
});
dialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        // 点击 Cancel 的逻辑
    }
});
dialog.show();
```

想关闭对话框，可以调用 `dismiss()` 方法。

```java
dialog.dismiss();
```

#### ProgressDialog

`ProgressDialog` 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，提示用户耐心地等待。

```java
ProgressDialog progressDialog = new ProgressDialog(Activity.this);
progressDialog.setTitle("This is ProgressDialog");
progressDialog.setMessage("Loading...");
progressDialog.setCancelable(true);
progressDialog.show();
```

想关闭对话框，同样可以调用 `dismiss()` 方法。

```java
progressDialog.dismiss();
```

### 基本布局

布局是一种可用于放置很多控件的容器，它可以按照一定的规律调整内部控件的位置。除了放置控件外，布局的内部也可以放置布局。通过多层布局的嵌套，我们能够完成一些复杂界面的实现。

#### LinearLayout

`LinearLayout` 又称作线性布局，是一种非常常用的布局。这个布局会将它所包含的控件在线性方向上依次排列。可以通过 `android:orientation` 属性指定排列方向，可取值有 `vertical` 和 `horizontal`。

`LinearLayout` 中还有一个重要属性 `android:layout_weight` 。这个属性允许我们使用比例的方式来指定控件的大小。当使用了 `android:layout_weight` 属性后，控件在排列方向上的尺寸就不应该再由 `android:layout_width` 来决定，一般指定成 `0dp` 。系统会将 LinearLayout 下所有控件指定的 `layout_weight` 值相加，得到一个总值，然后每个控件所占大小的比例就是用该控件的 `layout_weight` 值除以刚才算出的总值。我们还可以指定部分控件的 `layout_weight` 值。

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Buttonandroid:id="@+id/button1"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="Button1"/>

    <Buttonandroid:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_weight="2"
        android:text="Button2"/>
</LinearLayout>
```

#### RelativeLayout

`RelativeLayout` 可以通过相对定位的方式让控件出现在布局的任何位置。有如下控制属性:

- `android:layout_alignParentLeft` // 和父布局左对齐
- `android:layout_alignParentTop` // 和父布局上对齐
- `android:layout_alignParentRight` // 和父布局右对齐
- `android:layout_alignParentBottom` // 和父布局下对齐
- `android:layout_centerInParent` // 在父布局中心
- `android:layout_toLeftOf` // 在指定控件之左
- `android:layout_above` // 在指定控件之上
- `android:layout_toRightOf` // 在指定控件之右
- `android:layout_below` // 在指定控件之下
- `android:layout_alignLeft` // 和指定控件左对齐
- `android:layout_alignTop` // 和指定控件上对齐
- `android:layout_alignRight` // 和指定控件右对齐
- `android:layout_alignBottom` // 和指定控件下对齐

#### FrameLayout

`FrameLayout` 是一个十分轻量化的布局，没有特定的定位方式，所有的控件都默认摆放在布局的左上角。我们可以使用 `layout_gravity` 属性来指定控件在布局中的对齐方式。

#### PercentFrameLayout 和 PercentRelativeLayout

百分比布局允许直接指定控件在布局中所占的百分比。百分比布局定义在 support 库当中，需要在项目的 `build.gradle` 中添加百分比布局库的依赖。

```groovy
compile 'com.android.support:percent:25.3.1'
```

百分比布局为 `FrameLayout` 和 `RelativeLayout` 进行了功能扩展，使用 `app:layout_widthPercent` 属性可将控件的宽度指定为布局的百分比，使用 `app:layout_heightPercent` 属性可将控件的高度指定为布局的百分比。

### 自定义控件

所用的所有控件都是直接或间接继承自 `View` 的，所用的所有布局都是直接或间接继承自 `ViewGroup` 的。系统自带的控件不能满足我们的需求时，我们可以利用继承结构来创建自定义控件。

我们可以通过 `include` 语句将其他布局引入当前布局。

创建自定义控件时，要使自定义控件的类继承自控件 layout 的最外层布局，并重写构造方法。在构造方法中要借助 `LayoutInflater` 对标题栏布局进行动态加载，并可以进行注册监听器等操作。这样，就可以在其他布局中使用这个控件了。

### ListView

`ListView` 允许用户通过上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕。

```xml
<ListView android:id="@+id/list_view"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
```

`ListView` 需要使用适配器来填充数据。按照以下步骤使用 `ListView` ：

1. 定义实体类

    使用 `ListView` ，首先要定义一个实体类，作为 `ListView` 适配器的适配类型。

2. 定义条目布局

    需要为 `ListView` 的子项指定一个自定义的布局。

3. 创建适配器

    接下来需要创建一个自定义的适配器，继承自 `ArrayAdapter` ，并将泛型指定为之前定义的实体类。

    自定义适配器重写了父类的一组构造函数，用于将 `context` ， `ListView` 子项布局 id 和数据传递进来。

    还需要新建一个内部类 `ViewHolder` ，用于对条目控件的实例进行缓存。

    另外又重写了 `getView()` 方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。首先通过 `getItem()` 方法得到当前项的实例，然后在 `getView()` 方法中先进行判断，如果 `convertView` 为 `null` ，则加载布局，否则直接对 `convertView` 进行重用。

    加载布局时，首先使用 `LayoutInflater.inflate()` 来加载我们传入的布局。这里 `inflate()` 方法的第三个参数传 `false` ，表示只让在父布局中声明的 `layout` 属性生效，但不会为这个 `View` 添加父布局。因为一旦 `View` 有了父布局之后，它就不能再添加到 `ListView` 中了。接下来创建一个 `ViewHolder对象` ，并将控件的实例都存放在这个 `ViewHolder对象` 里。然后调用 `View` 的 `setTag()` 方法，将 `ViewHolder对象` 存储在 `View` 中。

    重用 `ViewHolder` 时，调用 `View` 的 `getTag()` 方法，把 `ViewHolder` 重新取出。这样所有控件的实例都缓存在 `ViewHolder` 里，避免每次都通过 `findViewById()` 方法获取控件实例。

    最后，将数据实例中的数据赋到 `ViewHolder` 中缓存的相应的控件上。

4. 实例化适配器

    在 Activity 中新建适配器的对象，并通过 `setAdapter()` 方法将其传递给 `ListView` 。

5. 添加点击事件

    在 Activity 中使用 `setOnItemClickListener()` 方法为 `ListView` 注册监听器。当用户点击了 ListView 中的一个子项时，就会回调 `onItemClick()` 方法。在这个方法中可以通过position参数判断出用户点击的是哪一个子项，然后执行相应逻辑。

### RecyclerView

`RecyclerView` 是一个增强版的 `ListView` ，不仅可以实现和 ListView 同样的效果，还优化了 ListView 中存在的各种不足之处。

#### 基本使用

`RecyclerView` 定义在 support 库当中。需要在项目的 `build.gradle` 中添加相应的依赖库。

```groovy
compile 'com.android.support:recyclerview-v7: 25.3.1'
```

`RecyclerView` 使用方法如下：

1. 在布局中添加 `RecyclerView`

    ```xml
    <android.support.v7.widget.RecyclerView
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
    ```

2. 定义实体类

    定义实体类，作为 `RecyclerView` 适配器的数据实体类型。

3. 定义条目布局

    为 `RecyclerView` 的子项指定自定义的布局。

4. 创建适配器

    新建适配器类，继承自 `RecyclerView.Adapter` 。

    根据定义的条目布局在适配器类内定义 ViewHolder 内部类，继承自 `RecyclerView.ViewHoler` 并重写构造方法。 ViewHolder 的构造方法中传入一个 `View` 参数，这个参数通常就是 RecyclerView 条目最外层布局，这样我们就可以通过 `findViewById()` 方法来获取到布局中的控件实例。

    在适配器中传入数据源。可以通过添加带数据参数构造方法将数据传入。

    重写适配器的 `onCreateViewHolder(ViewGroup parent, int viewType)` ， `onBindViewHolder(ViewHolder holder, int position)` 和 `getItemCount()` 方法。 `onCreateViewHolder()` 方法用于创建 ViewHolder 实例。在这个方法中通过 `LayoutInflater` 加载布局，然后构造一个 ViewHolder 实例并返回。 `onBindViewHolder()` 方法用于对 RecyclerView 条目的数据进行赋值，会在每个条目被滚动到屏幕内的时候执行，可以通过 `position` 参数从数据源得到当前项实例，然后再将数据设置到 `ViewHolder` 的相应控件当中。 `getItemCount()` 用于返回条目的总数。

    除此之外，还可以重写 `getItemViewType(int position)` 方法，这个方法用于多条目类型的 RecyclerView 。根据 `position` 参数判断当前条目类型并返回，这样在 `onCreateViewHolder()` 方法时就可以根据 `viewType` 参数来对不同类型的条目分别创建 ViewHolder 。

5. 实例化适配器

    `RecyclerView` 需要 `LayoutManager` 和 `Adapter` 才能正常工作。

    ```java
    RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
    LinearLayoutManager layoutManager = new LinearLayoutManager(context);
    MyAdapter adapter = new MyAdapter(data);
    recyclerView.setLayoutManager(layoutManager);
    recyclerView.setAdapter(adapter);
    ```

#### 横向滚动

在将 `LayoutManager` 赋给 RecyclerView 之前调用 `setOrientation(int orientation)` 并传值 `LinearLayoutManager.HORIZONTAL` 即可实现横向滚动。

```java
RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
LinearLayoutManager layoutManager = new LinearLayoutManager(context);
layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
recyclerView.setLayoutManager(layoutManager);
```

#### 瀑布流

使用 `StaggeredGridLayoutManager` 作为 `LayoutManager` 可以实现瀑布流效果。 `StaggeredGridLayoutManager` 的构造方法接收两个参数，第一个参数用于指定布局的列数，第二个参数用于指定布局的排列方向。

```java
RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_ view);
StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);
recyclerView.setLayoutManager(layoutManager);
```

### Nine-Patch图片

`Nine-Patch` 图片是一种被特殊处理过的 `png` 图片，能够指定哪些区域可以被拉伸、哪些区域不可以。

在 Android sdk 目录下有一个 `tools` 文件夹，在这个文件夹中找到 `draw9patch.bat` 文件。双击打开，在导航栏点击 `File` → `Open9-patch` 将 `png` 图片加载进来。我们可以在图片的边框绘制小黑点，上边框和左边框绘制的部分表示图片可拉伸的区域，下边框和右边框绘制的部分表示放置内容的区域。使用鼠标在图片的边缘拖动可以绘制，按住 `Shift` 键拖动可以进行擦除。最后点击导航栏 `File` → `Save9-patch` 保存绘制好的图片，此时的文件后缀名是 `.9.png` 。

[↑目录](#index)

------

<h2 id="chap4">第4章 Fragment</h2>

### 使用 Fragment

#### 简单用法

#### 动态添加

#### 使用限定符

### 模拟返回栈

### Fragment 和 Activity 间通信

### Fragment 的生命周期

#### Fragment 状态

#### Fragment 生命周期

[↑目录](#index)

------

<h2 id="chap5">第5章 BroadCast</h2>

[↑目录](#index)

<h2 id="chap6">第6章 数据持久化</h2>

[↑目录](#index)

<h2 id="chap7">第7章 Content Provider</h2>

[↑目录](#index)

<h2 id="chap8">第8章 多媒体</h2>

[↑目录](#index)

<h2 id="chap9">第9章 网络</h2>

[↑目录](#index)

<h2 id="chap10">第10章 Service</h2>

[↑目录](#index)

<h2 id="chap11">第11章 定位</h2>

[↑目录](#index)

<h2 id="chap12">第12章 Material Design</h2>

[↑目录](#index)

<h2 id="chap13">第13章 高级技巧</h2>

[↑目录](#index)

<h2 id="chap14">第14章 欧酷天气</h2>

[↑目录](#index)

<h2 id="chap15">第15章 发布应用</h2>

[↑目录](#index)
