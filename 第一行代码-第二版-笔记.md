# 第一行代码 Android 第2版

<h2 id="index">目录</h2>

- [第1章 开始](#chap1)
- [第2章 Activity](#chap2)
- [第3章 UI布局](#chap3)
- [第4章 Fragment](#chap4)
- [第5章 BroadCast](#chap5)
- [第6章 数据持久化](#chap6)
- [第7章 Content Provider](#chap7)
- [第8章 多媒体](#chap8)
- [第9章 网络](#chap9)
- [第10章 Service](#chap10)
- [第11章 定位](#chap11)
- [第12章 Material Design](#chap12)
- [第13章 高级技巧](#chap13)
- [第14章 酷欧天气](#chap14)
- [第15章 发布应用](#chap15)
- [Git 时间](#git)

------

<h2 id="chap1">第1章 开始</h2>

### Android 系统架构

| ·     | 架构         |
| :---: | ------------ |
| 顶层  | 应用层       |
| ↑     | 应用框架层   |
| ↑     | 系统运行库层 |
| 底层  | Linux内核层  |

### 搭建开发环境

安装 Android Studio → 配置 Android Studio → 创建项目 → 创建模拟器 → 运行项目

### 日志工具

Android 中提供了 Log 工具类 `android.util.Log` ，其中提供了5个方法用来输出不同级别的日志。

```java
Log.v(String tag, String msg); // 对应级别 verbose ，用来打印最琐碎的信息
Log.d(String tag, String msg); // 对应级别 debug ，用来打印调试信息
Log.i(String tag, String msg); // 对应级别 info ，用来打印比较重要的信息
Log.w(String tag, String msg); // 对应级别 warn ，用来打印警告信息
Log.e(String tag, String msg); // 对应级别 error ，用来打印程序错误
```

输出的日志会显示在 logcat 中。logcat 可以通过以下三种方式过滤日志。

- [过滤器](#filter.1)
- [日志级别控制](#filter.2)
- [关键字过滤](#filter.3)

<h4 id="filter.1">过滤器</h4>

有三种过滤器：'show only selected application', 'Firebase', 'No Filters'。除此之外，还可以使用 'Edit Filter Configuration' 自定义过滤器。

<h4 id="filter.2">日志级别控制</h4>

logcat中有5个级别，分别对应 Log 工具类中的5个级别。

<h4 id="filter.3">关键字过滤</h4>

关键字过滤支持正则表达式。

[↑目录](#index)

------

<h2 id="chap2">第2章 Activity</h2>

Activity 是一种可以包含用户界面的组件，主要用于和用户进行交互。

### 使用 Activity

创建 Activity → 创建 Layout 并加载 → 在 Manifest 中注册

### 使用 Toast

Android 中提供了 Toast 组件 `android.widget.Toast` ，可以通过静态方法 `makeText()` 进行创建。

```java
Toast.makeText(Context context, CharSequence text, @Duration int duration);
```

`makeText()` 方法需要3个参数， `context` 为上下文对象， `text` 为 Toast 显示的内容， `duration` 为 Toast 的持续时间，可取值为 `Toast.LENGTH_LONG` 和 `Toast.LENGTH_SHORT` 。

### 使用 Menu

新建 Menu 资源文件 → 重写 `OnCreateOptionsMenu()` 方法，通过 `MenuInflater.inflate()` 方法创建菜单 → 重写 `OnOptionsItemSelected()` 处理选择事件

### 销毁 Activity

使用 Activity 中的 `finish()` 方法。此方法效果等同于按下返回键。

### 使用 Intent

在 Activity 之间跳转需要使用 `android.content.Intent` 类。Intent大致可以分两种：**显式 Intent** 和**隐式 Intent** 。

#### 显式 Intent

显式 Intent 通过 `Intent(Context, Class<?>)` 来进行构造。 `packageContext` 参数传入当前应用的上下文对象， `cls` 参数传入目标 Activity 。然后，我们可以通过 Activity 中的 `startActivity(Intent intent)` 方法来启动目标 Activity。

```java
Intent intent = new Intent(context, TargetActivity.class);
startActivity(intent);
```

#### 隐式 Intent

隐式 Intent 并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的 `action` 和 `category` 等信息，然后交由系统去分析这个 Intent，并帮我们找出合适的活动去启动。通过在 `AndroidManifest.xml` 中的 `<activity>` 标签下配置 `<intent-filter>` 的内容， 可以指定当前 Activity 能够响应的 action 和 category。每个 Intent 中只能指定一个 action，但却能指定多个 category。

```xml
<activity android:name=".TargetActivity">
    <intent-filter>
        <action android:name="com.example.activitytest.ACTION_START"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <category android:name="com.example.activitytest.MY_CATEGORY">
    </intent-filter>
</activity>
```

接下来，我们就可以通过 `Intent(String)` 来构造 Intent。

```java
Intent intent = new Intent("com.example.activitytest.ACTION_START");
intent.addCategory("com.example.activitytest.MY_CATEGORY");
startActivity(intent);
```

使用隐式 Intent，我们不仅可以启动自己程序内的 Activity， 还可以启动其他程序的 Activity。

```java
Intent intent = new Intent(Intent.ACTION_VIEW);
intent.setData(Uri.parse("http://www.bing.com"));
startActivity(intent);
```

`setData()` 接收一个 `Uri` 对象，主要用于指定当前 Intent 正在操作的数据，而这些数据通常都是以字符串的形式传入到 `Uri.parse()` 方法中解析产生的。与此对应，我们可以在`<intent-filter>` 标签中再配置一个 `<data>` 标签，用于更精确地指定当前 Activity 能够响应什么类型的数据。只有 `<data>` 标签中指定的内容和 Intent 中携带的 Data 完全一致时， 当前 Activity 才能够响应该 Intent。 `<data>` 标签中主要可以配置以下内容。

- android:scheme 用于指定数据的协议部分。
- android:host 用于指定数据的主机名部分。
- android:port 用于指定数据的端口部分。
- android:path 用于指定主机名和端口之后的部分。
- android:mimeType 用于指定可以处理的数据类型，允许使用通配符的方式进行指定。

### Activity 间的数据传递

Intent 可以在 Activity 之间传递数据。

#### 向下一个 Activity 传递数据

Intent 中提供了一系列 `putExtra()` 方法的重载。可以通过该方法将数据暂存在 Intent 中，在目标 Activity 中从 Intent 取出就可以了。

```java
// 当前 Activity
String data1 = "Hello Target Activity";
int data2 = 123;
boolean data3 = true;
Intent intent = new Intent(context, TargetActivity.class);
intent.putExtra("string_extra", data1);
intent.putExtra("int_extra", data2);
intent.putExtra("boolean_extra", data3);
startActivity(intent);
```

```java
// 目标 Activity
Intent intent = getIntent();
String data1 = intent.getStringExtra("string_extra");
int data2 = intent.getIntExtra("int_extra", DEFAULT_INT);
boolean data3 = intent.getBooleanExtra("boolean_extra", DEFAULT_BOOLEAN);
```

#### 返回数据给上一个 Activity 并接收

Activity 中有一个 `startActivityForResult(Intent, int)` 方法，这个方法期望在 Activity 销毁的时候能够返回一个结果。第一个参数为 `Intent` ，第二个参数是请求码，需要是唯一值，用于在回调中判断数据的来源。

```java
Intent intent = new Intent(context, TargetActivity.class);
startActivityForResult(intent, REQUEST_TARGET);
```

在目标 Activity 中，可以构造一个新的 Intent 暂存数据，然后调用 `setResult(int, Intent)` 方法。第一个参数用于向上一个 Activity 返回处理结果，一般使用 `Activity.RESULT_OK` 或 `Activity.RESULT_CANCELED` 两个值，第二个参数把带有数据的 Intent 传递回去。最后调用 `finish()` 销毁 Activity。

```java
String data = "Hello Previous Activity";
Intent intent = new Intent();
intent.putExtra("data_result", data);
setResult(intent, RESULT_OK);
finish();
```

如果想要处理用户点击返回键时回传的数据，可以重写 `onBackPressed()` 方法。

在 TargetActivity 销毁后，会回调上一个 Activity 的 `onActivityResult(int, int, Intent)` 方法。我们需要重写上一个 Activity 中的 `onActivityResult(int, int, Intent)` 方法来接收回传数据。 `requestCode` 为我们在启动 TargetActivity 时传入的请求码。 `resultCode` 为我们在返回数据时传入的处理结果。 `data`为携带返回数据的 Intent。首先检查 `requestCode` 的值来判断数据来源。然后再通过 `resultCode` 的值来判断处理 结果。最后从 `data` 中取值。

```java
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    switch (requestCode) {
        case REQUEST_TARGET:
            if (RESULT_OK == resultCode) {
                String result = data.getStringExtra("data_result");
            }
            break;

        default:
            break;
    }
}
```

### Activity 的生命周期

#### 返回栈

Android 使用任务 (Task) 来管理 Activity ，一个任务就是一组存放在栈里的 Activity 的集合，这个栈也被称作返回栈 (BackStack)。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的 Activity ，它会在返回栈中入栈，并处于栈顶的位置。而每当我们按下返回键或调用 `finish()` 方法去销毁一个 Activity 时，处于栈顶的 Activity 会出栈，这时前一个入栈的 Activity 就会重新处于栈顶的位置。系统总是会显示处于栈顶的 Activity 给用户。

#### Activity 状态

- 运行状态： Activity 处于栈顶时的状态。
- 暂停状态： Activity 不处于栈顶但依然可见时的状态。
- 停止状态： Activity 不处于栈顶并完全不可见时的状态。
- 销毁状态： Activity 被移出返回栈之后的状态。

#### Activity 生命周期

- `onCreate(Bundle)` // Activity 第一次创建时调用。用于完成初始化操作。
- `onStrat()` // Activity 由不可见变为可见时调用。
- `onResume()` // Activity 准备和用户交互时调用。此时 Activity 一定处于栈顶并是运行状态。
- `onPause()` // 系统准备启动或恢复其他 Activity 时调用。
- `onStop()` // Activity 变为不可见时调用。
- `onDestroy()` // Activity 销毁之前调用，执行后 Activity 变为销毁状态。
- `onRestart()` // Activity 由停止状态变为运行状态之前调用。

![Activity 生命周期](https://developer.android.google.cn/images/activity_lifecycle.png "Activity Lifecycle")

#### Activity 被回收的处理

当一个 Activity 进入停止状态，是有可能被系统回收的。在 Activity 被系统回收后，再次返回该 Activity 时不会调用 `onRestart()` 方法，而是调用 `onCreate()` 方法再次创建。如此该 Activity 中的状态和暂存数据都会丢失。 要解决这个问题，可以重写 `onSaveInstanceState(Bundle)` 方法。该方法在 Activity 被回收之前一定会被调用。 `outState` 参数是一个 `android.os.Bundle` 类型，用来保存状态和临时数据。

```java
@Override
protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    String tempData = "some temp data";
    outState.putString("temp_string", tempData);
}
```

在 Activity 的 `onCreate(Bundle)` 方法中，带有一个 `Bundle` 类型参数 `savedInstanceState` 。这个参数就是通过 `onSaveInstanceState(Bundle)` 保存下来的数据。要恢复状态和暂存数据，在其中取出相应数据即可。

```java
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    if (null != savedInstanceState) {
        String tempData = savedInstanceState.getString("temp_string");
    }
}
```

### Activity 的启动模式

Activity 的启动模式一共有4种，分别是 `standard` ， `singleTop` ， `singleTask` 和 `singleInstance` 。可以在 `AndroidManifest.xml` 中通过给 `<activity>` 标签指定 `android:launchMode` 属性来选择启动模式。

#### standard

是 Activity 的默认启动模式，不需要进行额外配置。使用 standard 模式，每当启动一个新的 Activity ，不管这个 Activity 是否已经在返回栈中存在，都会创建一个新的对象入栈，并处于栈顶的位置。

#### singleTop

使用 singleTop 模式，当启动一个新的 Activity 时，若有一个该 Activity 的对象在栈顶，则直接使用该对象。否则，新建一个该 Activity 的对象入栈。

```xml
<activity
    android:name=".SingleTopActivity"
    android:launchMode="singleTop">
</activity>
```

#### singleTask

使用 singleTask 模式，每次启动该 Activity 时系统首先会在返回栈中检查是否存在该 Activity 的对象，如果发现已经存在则直接使用该对象，并把在这个活动之上的所有 Activity 出栈。如果没有发现就会创建一个新的 Activity 对象入栈。

```xml
<activity
    android:name=".SingleTaskActivity"
    android:launchMode="singleTask">
</activity>
```

#### singleInstance

使用 singleInstance 模式，系统会启用一个新的返回栈来管理该 Activity 。不管是哪个应用程序来访问这个 Activity ，都共用同一个返回栈。

```xml
<activity
    android:name=".SingleInstanceActivity"
    android:launchMode="singleInstance">
</activity>
```

### 最佳实践

#### 判断当前在哪一个 Activity

可以创建 BaseActivity 并添加如下方法，并使所有 Activity 都继承该 BaseActivity 。该方法可以返回当前 Activity 类名的字符串。

```java
public class BaseActivity extends AppCompatActivity {
    protected String getCurrentActivityName() {
        return getClass().getSimpleName();
    }
}
```

#### 随时退出程序

在项目中创建一个 `ActivityCollector` 管理类。

```java
public class ActivityCollector {
    public static List<Activity> activities = new ArrayList<>();

    public static void addActivity(Activity activity) {
        activities.add(activity);
    }

    public static void removeActivity(Activity activity) {
        activities.remove(activity);
    }

    public static void finishAll() {
        for (Activity activity : activities) {
            if (!activity.isFinishing()) {
                activity.finish();
            }
        }
        activities.clear();
    }
}
```

在 `BaseActivity` 的添加如下代码：

```java
public class BaseActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityCollector.addActivity(this);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        ActivityCollector.removeActivity(this);
    }
}
```

经过以上处理，在想退出的地方直接调用 `ActivityCollector.finishAll()` 即可销毁所有 Activity ，退出程序。为了完全退出，还可以在销毁所有活动后添加结束进程的代码。

```java
android.os.Process.killProcess(android.os.Process.myPid());
```

#### 最佳启动 Activity 方法

标准的开启 Activity 方法中，当需要在 Activity 之间传递数据时，必须在当前和目标 Activity 分别存入和取出数据。这样不是很直接，又可能出现一些对接问题。我们可以在目标 Activity 添加一个静态方法来解决。

```java
public class TargetActivity extends BaseActivity {
    public static void actionStart(Context context, String data1, int data2) {
        Intent intent = new Intent(context, TargetActivity.class);
        intent.putExtra("data1", data1);
        intent.putExtra("data2", data2);
        context.startActivity(intent);
    }
}
```

这样，当前 Activity 调用 `actionStart()` 方法，需要传递哪些数据一目了然。

[↑目录](#index)

------

<h2 id="chap3">第3章 UI布局</h2>

Android 使用 `XML` 代码来编写界面。

### 常用控件

#### TextView

`TextView` 主要用于在界面上显示一段文本信息。

```xml
<TextView android:id="@+id/text_view"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:gravity="center"
    android:textSize="24sp"
    android:textColor="#00ff00"
    android:text="This is TextView" />
```

#### Button

`Button` 按钮，是程序用于和用户进行交互的一个重要控件。

```xml
<Button android:id="@+id/button"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Button" />
```

Button 中所有英文字母会自动转换为大写，可以添加 `android:textAllCaps="false"` 来禁用。

Button 还需要注册一个点击事件监听器才能响应点击事件。点击按钮时，会执行监听器中的 `onClick(View)` 方法。

```java
Button button = (Button) findViewById(R.id.button);
button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        // 在此处添加逻辑
    }
});
```

#### EditText

`EditText` 允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理。可以使用 `android:hint` 属性指定提示性的文本，当我们输入任何内容时，这段文本就会自动消失。

```xml
<EditText android:id="@+id/edit_text"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:maxLines="2"
    android:hint="Type something here" />
```

在程序中，可以通过 `getText()` 方法获取输入的文本。

```java
EditText editText = (EditText) findViewById(R.id.edit_text);
String inputText = editText.getText().toString();
```

#### ImageView

`ImageView` 是用来在界面上展示图片的一个控件。图片资源通常都是放在以 `drawable` 开头的目录下的。

```xml
<ImageView android:id="@+id/image_view"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:src="@ drawable/img_1"/>
```

在程序中，还可以使用代码动态设置 ImageView 的图片。

```java
ImageView imageView = (ImageView) findViewById(R.id.image_view);
imageView.setImageResource(R.drawable.img_2);
```

#### ProgressBar

`ProgressBar` 用于在界面上显示一个进度条，表示程序正在加载一些数据。

```xml
<ProgressBar android:id="@+id/progress_bar"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"/>
```

想要让进度条消失，可以设置 Android 控件的可见属性。可见性可以在控件属性中加入 `android:visibility` 进行指定，可选值有 3 种： `visible` ， `invisible` 和 `gone` 。 `visible` 是默认值，表示控件是可见的。 `invisible` 表示控件不可见，但是仍然占据原来的位置和大小。 `gone` 则表示控件不仅不可见，而且不再占用任何屏幕空间。如果想通过代码设置可见属性，需要使用 `setVisibility(int)` 方法。可传值为`View.VISIBLE` ， `View.INVISIBLE` 和 `View.GONE` 。

```java
ProgressBar progressBar = (ProgressBar) findViewById(R.id.progress_bar);
progressBar.setVisibility(View.GONE);
```

ProgressBar 还可以指定不同的样式。通过 `style` 属性可以将它指定成水平进度条，通过 `android:max` 属性给进度条设置一个最大值。

```xml
<ProgressBar android:id="@+id/progress_bar"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    style="?android:attr/progressBarStyleHorizontal"
    android:max="100"/>
```

在代码中，可以动态更改进度条的进度。

```java
ProgressBar progressBar = (ProgressBar) findViewById(R.id.progress_bar);
int newProgress = lastProgress + 10;
progressBar.setProgress(newProgress);
```

#### AlertDialog

`AlertDialog` 可以在当前的界面弹出一个对话框，置顶于所有界面元素之上，屏蔽其他控件的交互能力。 `AlertDialog` 一般用于提示一些非常重要的内容或者警告信息。

```java
AlertDialog.Builder dialog = new AlertDialog.Builder(Activity.this);
dialog.setTitle("This is Dialog");
dialog.setMessage("Something important.");
dialog.setCancelable(false);
dialog.setPositiveButton("OK", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        // 点击 OK 的逻辑
    }
});
dialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        // 点击 Cancel 的逻辑
    }
});
dialog.show();
```

想关闭对话框，可以调用 `dismiss()` 方法。

```java
dialog.dismiss();
```

#### ProgressDialog

`ProgressDialog` 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，提示用户耐心地等待。

```java
ProgressDialog progressDialog = new ProgressDialog(Activity.this);
progressDialog.setTitle("This is ProgressDialog");
progressDialog.setMessage("Loading...");
progressDialog.setCancelable(true);
progressDialog.show();
```

想关闭对话框，同样可以调用 `dismiss()` 方法。

```java
progressDialog.dismiss();
```

### 基本布局

布局是一种可用于放置很多控件的容器，它可以按照一定的规律调整内部控件的位置。除了放置控件外，布局的内部也可以放置布局。通过多层布局的嵌套，我们能够完成一些复杂界面的实现。

#### LinearLayout

`LinearLayout` 又称作线性布局，是一种非常常用的布局。这个布局会将它所包含的控件在线性方向上依次排列。可以通过 `android:orientation` 属性指定排列方向，可取值有 `vertical` 和 `horizontal`。

`LinearLayout` 中还有一个重要属性 `android:layout_weight` 。这个属性允许我们使用比例的方式来指定控件的大小。当使用了 `android:layout_weight` 属性后，控件在排列方向上的尺寸就不应该再由 `android:layout_width` 来决定，一般指定成 `0dp` 。系统会将 LinearLayout 下所有控件指定的 `layout_weight` 值相加，得到一个总值，然后每个控件所占大小的比例就是用该控件的 `layout_weight` 值除以刚才算出的总值。我们还可以指定部分控件的 `layout_weight` 值。

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Buttonandroid:id="@+id/button1"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="Button1"/>

    <Buttonandroid:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_weight="2"
        android:text="Button2"/>
</LinearLayout>
```

#### RelativeLayout

`RelativeLayout` 可以通过相对定位的方式让控件出现在布局的任何位置。有如下控制属性:

- `android:layout_alignParentLeft` // 和父布局左对齐
- `android:layout_alignParentTop` // 和父布局上对齐
- `android:layout_alignParentRight` // 和父布局右对齐
- `android:layout_alignParentBottom` // 和父布局下对齐
- `android:layout_centerInParent` // 在父布局中心
- `android:layout_toLeftOf` // 在指定控件之左
- `android:layout_above` // 在指定控件之上
- `android:layout_toRightOf` // 在指定控件之右
- `android:layout_below` // 在指定控件之下
- `android:layout_alignLeft` // 和指定控件左对齐
- `android:layout_alignTop` // 和指定控件上对齐
- `android:layout_alignRight` // 和指定控件右对齐
- `android:layout_alignBottom` // 和指定控件下对齐

#### FrameLayout

`FrameLayout` 是一个十分轻量化的布局，没有特定的定位方式，所有的控件都默认摆放在布局的左上角。我们可以使用 `layout_gravity` 属性来指定控件在布局中的对齐方式。

#### PercentFrameLayout 和 PercentRelativeLayout

百分比布局允许直接指定控件在布局中所占的百分比。百分比布局定义在 support 库当中，需要在项目的 `build.gradle` 中添加百分比布局库的依赖。

```groovy
compile 'com.android.support:percent:26.1.0'
```

百分比布局为 `FrameLayout` 和 `RelativeLayout` 进行了功能扩展，使用 `app:layout_widthPercent` 属性可将控件的宽度指定为布局的百分比，使用 `app:layout_heightPercent` 属性可将控件的高度指定为布局的百分比。

### 自定义控件

所用的所有控件都是直接或间接继承自 `View` 的，所用的所有布局都是直接或间接继承自 `ViewGroup` 的。系统自带的控件不能满足我们的需求时，我们可以利用继承结构来创建自定义控件。

我们可以通过 `include` 语句将其他布局引入当前布局。

创建自定义控件时，要使自定义控件的类继承自控件 layout 的最外层布局，并重写构造方法。在构造方法中要借助 `LayoutInflater` 对标题栏布局进行动态加载，并可以进行注册监听器等操作。这样，就可以在其他布局中使用这个控件了。

### ListView

`ListView` 允许用户通过上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕。

```xml
<ListView android:id="@+id/list_view"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
```

`ListView` 需要使用适配器来填充数据。按照以下步骤使用 `ListView` ：

1. 定义实体类

    使用 `ListView` ，首先要定义一个实体类，作为 `ListView` 适配器的适配类型。

2. 定义条目布局

    需要为 `ListView` 的子项指定一个自定义的布局。

3. 创建适配器

    接下来需要创建一个自定义的适配器，继承自 `ArrayAdapter` ，并将泛型指定为之前定义的实体类。

    自定义适配器重写了父类的一组构造函数，用于将 `context` ， `ListView` 子项布局 id 和数据传递进来。

    还需要新建一个内部类 `ViewHolder` ，用于对条目控件的对象进行缓存。

    另外又重写了 `getView()` 方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。首先通过 `getItem()` 方法得到当前项的实例，然后在 `getView()` 方法中先进行判断，如果 `convertView` 为 `null` ，则加载布局，否则直接对 `convertView` 进行重用。

    加载布局时，首先使用 `LayoutInflater.inflate()` 来加载我们传入的布局。这里 `inflate()` 方法的第三个参数传 `false` ，表示只让在父布局中声明的 `layout` 属性生效，但不会为这个 `View` 添加父布局。因为一旦 `View` 有了父布局之后，它就不能再添加到 `ListView` 中了。接下来创建一个 `ViewHolder对象` ，并将控件的 对象都存放在这个 `ViewHolder对象` 里。然后调用 `View` 的 `setTag()` 方法，将 `ViewHolder对象` 存储在 `View` 中。

    重用 `ViewHolder` 时，调用 `View` 的 `getTag()` 方法，把 `ViewHolder` 重新取出。这样所有控件的 对象都缓存在 `ViewHolder` 里，避免每次都通过 `findViewById()` 方法获取控件 对象。

    最后，将数据 对象中的数据赋到 `ViewHolder` 中缓存的相应的控件上。

4. 实例化适配器

    在 Activity 中新建适配器的对象，并通过 `setAdapter()` 方法将其传递给 `ListView` 。

5. 添加点击事件

    在 Activity 中使用 `setOnItemClickListener()` 方法为 `ListView` 注册监听器。当用户点击了 ListView 中的一个子项时，就会回调 `onItemClick()` 方法。在这个方法中可以通过position参数判断出用户点击的是哪一个子项，然后执行相应逻辑。

### RecyclerView

`RecyclerView` 是一个增强版的 `ListView` ，不仅可以实现和 ListView 同样的效果，还优化了 ListView 中存在的各种不足之处。

#### 基本使用

`RecyclerView` 定义在 support 库当中。需要在项目的 `build.gradle` 中添加相应的依赖库。

```groovy
compile 'com.android.support:recyclerview-v7: 26.1.0'
```

`RecyclerView` 使用方法如下：

1. 在布局中添加 `RecyclerView`

    ```xml
    <android.support.v7.widget.RecyclerView
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
    ```

2. 定义实体类

    定义实体类，作为 `RecyclerView` 适配器的数据实体类型。

3. 定义条目布局

    为 `RecyclerView` 的子项指定自定义的布局。

4. 创建适配器

    新建适配器类，继承自 `RecyclerView.Adapter` 。

    根据定义的条目布局在适配器类内定义 ViewHolder 内部类，继承自 `RecyclerView.ViewHoler` 并重写构造方法。 ViewHolder 的构造方法中传入一个 `View` 参数，这个参数通常就是 RecyclerView 条目最外层布局，这样我们就可以通过 `findViewById()` 方法来获取到布局中的控件 对象。

    在适配器中传入数据源。可以通过添加带数据参数构造方法将数据传入。

    重写适配器的 `onCreateViewHolder(ViewGroup, int)` ， `onBindViewHolder(ViewHolder, int)` 和 `getItemCount()` 方法。 `onCreateViewHolder()` 方法用于创建 ViewHolder 对象。在这个方法中通过 `LayoutInflater` 加载布局，然后构造一个 ViewHolder 对象并返回。 `onBindViewHolder()` 方法用于对 RecyclerView 条目的数据进行赋值，会在每个条目被滚动到屏幕内的时候执行，可以通过 `position` 参数从数据源得到当前项数据，然后再将数据设置到 `ViewHolder` 的相应控件当中。 `getItemCount()` 用于返回条目的总数。

    除此之外，还可以重写 `getItemViewType(int)` 方法，这个方法用于多条目类型的 RecyclerView 。根据 `position` 参数判断当前条目类型并返回，这样在 `onCreateViewHolder()` 方法时就可以根据 `viewType` 参数来对不同类型的条目分别创建 ViewHolder 。

5. 实例化适配器

    `RecyclerView` 需要 `LayoutManager` 和 `Adapter` 才能正常工作。

    ```java
    RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
    LinearLayoutManager layoutManager = new LinearLayoutManager(context);
    MyAdapter adapter = new MyAdapter(data);
    recyclerView.setLayoutManager(layoutManager);
    recyclerView.setAdapter(adapter);
    ```

#### 横向滚动

在将 `LayoutManager` 赋给 RecyclerView 之前调用 `setOrientation(int)` 并传值 `LinearLayoutManager.HORIZONTAL` 即可实现横向滚动。

```java
RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
LinearLayoutManager layoutManager = new LinearLayoutManager(context);
layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
recyclerView.setLayoutManager(layoutManager);
```

#### 瀑布流

使用 `StaggeredGridLayoutManager` 作为 `LayoutManager` 可以实现瀑布流效果。 `StaggeredGridLayoutManager` 的构造方法接收两个参数，第一个参数用于指定布局的列数，第二个参数用于指定布局的排列方向。

```java
RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_ view);
StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);
recyclerView.setLayoutManager(layoutManager);
```

### Nine-Patch图片

`Nine-Patch` 图片是一种被特殊处理过的 `png` 图片，能够指定哪些区域可以被拉伸、哪些区域不可以。

在 Android sdk 目录下有一个 `tools` 文件夹，在这个文件夹中找到 `draw9patch.bat` 文件。双击打开，在导航栏点击 `File` → `Open9-patch` 将 `png` 图片加载进来。我们可以在图片的边框绘制小黑点，上边框和左边框绘制的部分表示图片可拉伸的区域，下边框和右边框绘制的部分表示放置内容的区域。使用鼠标在图片的边缘拖动可以绘制，按住 `Shift` 键拖动可以进行擦除。最后点击导航栏 `File` → `Save9-patch` 保存绘制好的图片，此时的文件后缀名是 `.9.png` 。

[↑目录](#index)

------

<h2 id="chap4">第4章 Fragment</h2>

`Fragment` 是一种可以嵌入 Activity 中的 UI 片段，它能让程序更加合理和充分地利用大屏幕的空间。

### 使用 Fragment

#### 简单用法

1. 创建布局文件

2. 新建 Fragment 类继承自 `android.support.v4.app.Fragment`

3. 重写 `onCreateView(LayoutInflater, ViewGroup, Bundle)` 加载布局

    ```java
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle
            savedInstanceState) {
        View view = inflater.inflate(R.layout.right_fragment, container, false);
        return view;
    }
    ```

4. 在 Activity 布局中添加 Fragment

    ```xml
    <fragment android:id="@+id/fragment"
        android:name="com.example.fragment.TestFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
    ```

#### 动态添加

1. 创建布局文件

2. 新建 Fragment 类继承自 `android.support.v4.app.Fragment`

3. 重写 `onCreateView(LayoutInflater, ViewGroup, Bundle)` 加载布局

    ```java
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle
            savedInstanceState) {
        View view = inflater.inflate(R.layout.right_fragment, container, false);
        return view;
    }
    ```

4. 在 Activity 的 Layout 中添加布局控件以放置 Fragment

    ```xml
    <FrameLayout android:id="@+id/fragment_container"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
    ```

5. 在 Activity 中动态替换 Fragment

    1. 创建待添加的 `Fragment` 对象。
    2. Activity 中通过调用 `getSupportFragmentManager()` 方法获取 `FragmentManager`
    3. 调用 `beginTransaction()` 方法开启一个事务。
    4. 向容器内添加或替换 `Fragment` ，一般使用 `replace()` 方法实现，需要传入容器的 id 和待添加的 Fragment 对象。
    5. 调用 `commit()` 方法提交事务。

    ```java
    TestFragment fragment = new TestFragment(context);
    FragmentManager fragmentManager = getSupportFragmentManager();
    FragmentTransaction transaction = fragmentManager.beginTransaction();
    transaction.replace(R.id.fragment_container, fragment);
    transaction.commit();
    ```

#### 使用限定符

在工程的 `res` 目录下新建 `layout-large` 文件夹。其中 `large` 是一个限定符，屏幕被认为是 `large` 的设备就会自动加载 `layout-large` 文件夹下的布局，而其他的设备则还加载 `layout` 文件夹下的布局。 Android 中一些常见的限定符如下：

- 屏幕大小
  - small
  - medium
  - large
  - xlarge

- 分辨率
  - ldpi
  - mdpi
  - hdpi
  - xhdpi
  - xxhdpi

- 方向
  - land
  - port

通过在工程的 `res` 目录下新建 `layout-sw***dp` 文件夹，我们可以指定最小宽度限定符。最小宽度限定符允许我们对屏幕的宽度指定一个最小值（以 `dp` 为单位），然后以这个最小值为临界点，屏幕宽度大于这个值的设备加载该文件夹内的布局，屏幕宽度小于这个值的设备加载其他文件夹内的布局。

### 模拟返回栈

`FragmentTransaction` 中提供了一个 `addToBackStack(String)` 方法，可以用于将一个事务添加到返回栈中。

```java
TestFragment fragment = new TestFragment(context);
FragmentManager fragmentManager = getSupportFragmentManager();
FragmentTransaction transaction = fragmentManager.beginTransaction();
transaction.addToBackStack(null);
transaction.replace(R.id.fragment_container, fragment);
transaction.commit();
```

### Fragment 和 Activity 间通信

调用 `FragmentManager` 的 `findFragmentById()` 方法，可以在 Activity 中得到相应 `Fragment` 的对象，然后就能调用 Fragment 里的方法。

```java
FragmentManager fragmentManager = getSupportFragmentManager();
TestFragment fragment = (TestFragment) fragmentManager.findFragmentById(R.id.fragment_container);
```

在 `Fragment` 中可以通过调用 `getActivity()` 方法来得到和当前 Fragment 相关联的 Activity 对象。

```java
MainActivity activity = (MainActivity) getActivity();
```

在一个 Fragment 中得到与它相关联的Activity ，然后再通过这个 Activity 去获取另外一个 Fragment 的对象，这样就可以实现不同 Fragment 之间的通信功能。

### Fragment 的生命周期

`Fragment` 拥有和 `Activity` 相似的生命周期。

#### Fragment 状态

- 运行状态： Fragment 是可见的，并且其所关联的 Activity 正处于运行状态。
- 暂停状态： Activity 进入暂停状态时，与其相关联的可见 Fragment 会进入暂停状态。
- 停止状态： Activity 进入停止状态时，与其相关联的 Fragment 会进入停止状态。通过调用 `FragmentTransaction` 的 `remove()` ， `replace()` 方法将 Fragment 从 Activity 中移除，但在事务提交之前调用 `addToBackStack()` 方法， Fragment 也会进入停止状态。进入停止状态的 Fragment 对用户来说完全不可见。
- 销毁状态： 当 Activity 被销毁时，与其相关联的 Fragment 会进入销毁状态。通过调用 `FragmentTransaction` 的 `remove()` ， `replace()` 方法将 Fragment 从 Activity 中移除，但在事务提交之前并没有调用 `addToBackStack()` 方法， Fragment 也会进入销毁状态。

#### Fragment 生命周期

- `onAttach(Activity)` // Fragment 和 Activity 建立关联时调用。
- `onCreate(Bundle)` // Fragment 第一次创建时调用。用于完成初始化操作。
- `onCreateView(LayoutInflater, ViewGroup, Bundle)` // Fragment 创建 View （加载布局）时调用。
- `onActivityCreated(Bundle)` // 确保与 Fragment 相关联的 Activity 已经创建完毕时调用。
- `onStart()` // Fragment 由不可见变为可见时调用。
- `onResume()` // Fragment 准备和用户交互时调用。此时其关联的 Activity 一定处于栈顶并是运行状态。
- `onPause()` // Fragment 关联的 Activity 进入暂停状态， Fragment 暂停和用户交互时调用。
- `onStop()` // Fragment 变为不可见时调用。
- `onDestroyView()` // 当与 Fragment 关联的 View 被移除时调用。
- `onDestroy()` // Fragment 销毁之前调用，执行后 Fragment 变为销毁状态。
- `onDetach()` // Fragment 和 Activity 解除关联时调用。

![Fragment 生命周期](https://developer.android.google.cn/images/fragment_lifecycle.png "Fragment Lifecycle")

[↑目录](#index)

------

<h2 id="chap5">第5章 BroadCast</h2>

Android 提供了一套完整的 API，允许应用程序发送和接收 BroadCast 。发送 BroadCast 的方法是借助 `Intent` 。而接收 BroadCast 则需要通过 `BroadcastReceiver` 。

### 广播机制

Android 中的每个应用程序都可以对感兴趣的 BroadCast 进行注册， 这样该程序就只会接收到注册类型的 BroadCast 内容。

### 接收广播

接收 BroadCast 需要注册 `BroadcastReceiver` 。

<h4 id="dyn_reg">动态注册</h2>

1. 定义 BroadcastReceiver

    定义一个 `BroadcastReceiver` 类，继承自 `android.content.BroadcastReceiver` 并重写其中的 `onReceive(Context, Intent)` 方法添加逻辑。每当收到相应 BroadCast 的时候就会执行 `onReceive(Context, Intent)` 方法。不要在 `onReceive(Context, Intent)` 方法中添加过多的逻辑或进行任何耗时操作，因为在 BroadcastReceiver 中不允许开启线程，当 `onReceive(Context, Intent)` 方法运行较长时间而没有结束时，程序会报错。

2. 创建 IntentFilter 对象

    在需要接收 BroadCast 处创建一个 `IntentFilter` 的对象，并调用 `addAction(String)` 方法添加 action 。此 action 就是程序想要接收的 BroadCast 类型。还可以调用 `setPriority(int)` 方法声明优先级。

3. 创建 BroadcastReceiver 对象

    创建刚才自定义的 BroadcastReceiver 的对象。

4. 注册 BroadcastReceiver

    调用 `registerReceiver(BroadcastReceiver, IntentFilter)` 方法对 BroadcastReceiver 进行注册。

5. 取消注册 BroadcastReceiver

    动态注册的 BroadcastReceiver 一定要在适当的位置取消注册。 调用 `unregisterReceiver(BroadcastReceiver)` 方法即可实现。取消注册操作一般在 `onDestroy()` 方法中进行。

6. 添加权限

    如果程序需要进行用户比较敏感的操作，就必须在打开 `AndroidManifest. xml` 文件中声明权限才可以，否则程序将会直接崩溃。

#### 静态注册

动态注册的 BroadcastReceiver 可以自由地注册与注销，但是它必须在程序启动后才能接收 Broadcast 。而静态注册的方式可以让程序在未启动的情况下就能接收到 BroadCast 。静态注册就是在 `AndroidManifest.xml` 中注册。

1. 定义 BroadcastReceiver

    同[动态注册](#dyn_reg)。

2. 注册 BroadcastReceiver

    在 `<application>` 标签内添加新的标签 `<receiver>` 来注册静态的 BroadcastReceiver 。在 `<receiver>` 标签中添加 `android:name` 属性来指定注册的 BroadcastReceiver 类名， `enabled` 属性指定是否启用这个 BroadcastReceiver ， `exported` 属性指定是否允许这个 BroadcastReceiver 接收本程序以外的 Broadcast 。在 `<receiver>` 标签内添加新的标签 `<intent-filter>` ，并在标签内添加新的标签 `<action>` 。每一个 `<action>` 标签对应一个 BroadCast 的 action ，在标签中添加 `android:name` 属性指定想要接收的 BroadCast 类型。 `<intent-filter>` 标签还可以添加 `android:priority` 属性来声明优先级。

3. 添加权限

    在 `AndroidManifest. xml` 文件中声明相应权限。

### 发送广播

<h4 id="snd_nor_bc">发送标准广播</h2>

标准广播（Normal broadcasts）是一种异步执行的 BroadCast 。在 BroadCast 发出之后，所有的 BroadCastReceiver 会在同一时刻接收到这条 BroadCast 。它们之间没有任何先后顺序可言，它是无法被截断的。

1. 构造 `Intent` 对象

    新建 `Intent` 对象，并调用 `setAction(String)` 方法添加 action 。还可以按需求在 Intent 对象中暂存数据。

2. 发送 BroadCast

    调用 `sendBroadcast(Intent)` 方法发送 BroadCast 。该方法在 `android.content.Context` 中。

#### 发送有序广播

有序广播（Ordered broadcasts）是一种同步执行的 BroadCast 。在 BroadCast 发出之后，同一时刻只会有一个 BroadCastReceiver 能够收到这条 BroadCast 。当这个 BroadCastReceiver 中的逻辑执行完毕后， BroadCast 才会继续传递。此时 BroadCastReceiver 是有先后顺序的，优先级高的 BroadCastReceiver 可以先收到 BroadCast ，并且前面的 BroadCastReceiver 还可以截断正在传递的 BroadCast ，使后面的 BroadCastReceiver 无法收到 BroadCast 。

1. 构造 `Intent` 对象

    同[发送标准广播](#snd_nor_bc)。

2. 发送 BroadCast

    调用 `sendOrderedBroadcast(Intent, String)` 方法发送 BroadCast 。该方法在 `android.content.Context` 中。 `String` 类型参数是一个与权限相关的字符串，可以传入 `null` 。

3. 截断 BroadCast

    在 `BroadCastReceiver` 中的 `onReceive(Context, Intent)` 方法中调用 `abortBroadcast()` 方法即可截断 BroadCast 。

### 本地广播

本地广播（Local Broadcast）发出的 BroadCast 只能在应用程序内部传递，并且 BroadCastReceiver 也只能接收来自本应用程序发出的 BroadCast 。本地广播相对全局广播有以下优势：

- 可以明确知道正在发送的广播不会离开程序，不必担心机密数据泄漏。
- 其他程序无法将广播发送到程序内部，不必担心安全漏洞的隐患。
- 发送本地广播比发送系统全局广播更加高效。

#### 发送本地广播

1. 构造 `Intent` 对象

    同[发送标准广播](#snd_nor_bc)。

2. 发送 BroadCast

    调用 `LocalBroadcastManager.getInstance(Context)` 获取 LocalBroadcastManager 对象。然后调用其中的 `sendBroadcast(Intent)` 方法发送 BroadCast 。

#### 接收本地广播

本地广播无法通过静态注册的方式来接收，只能在代码中动态注册。

1. 定义 BroadcastReceiver

    同[动态注册](#dyn_reg)。

2. 创建 IntentFilter 对象

    同[动态注册](#dyn_reg)。

3. 创建 BroadcastReceiver 对象

    同[动态注册](#dyn_reg)。

4. 注册 BroadcastReceiver

    调用 `LocalBroadcastManager.getInstance(Context)` 获取 LocalBroadcastManager 对象。然后调用其中的 `registerReceiver(BroadcastReceiver, IntentFilter)` 方法注册 BroadcastReceiver 。

5. 取消注册 BroadcastReceiver

    调用 LocalBroadcastManager 对象的 `unRegisterReceiver(BroadcastReceiver)` 方法取消注册 BroadcastReceiver 。

[↑目录](#index)

------

<h2 id="chap6">第6章 数据持久化</h2>

数据持久化是指将内存中的瞬时数据保存到存储设备中，保证即使在手机或电脑关机的情况下，这些数据仍然不会丢失。

### 文件存储

文件存储是 Android 中最基本的数据存储方式，它不对存储的内容进行任何的格式化处理。因而适合存储一些简单的文本数据或二进制数据。

#### 写入到文件

`Context` 类中提供了一个 `openFileOutput(String, int)` 方法，用于将数据存储到指定的文件中。该方法返回一个 `FileOutputStream` 对象。 `String` 参数是不包含路径的文件名，在文件创建的时候将使用这个文件名。文件默认存储到 `/data/data/<package-name>/files/` 目录下。 `int` 参数是文件的操作模式，有两种可选，`MODE_PRIVATE` 和 `MODE_APPEND` ，其他模式已经废弃。 `MODE_PRIVATE` 是默认操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原文件中的内容。而 `MODE_APPEND` 则表示如果该文件已存在，就往文件里面追加内容，不存在就创建新文件。

```java
try {
    FileOutputStream out = openFileOutput("data", Context.MODE_PRIVATE);
    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out));
    writer.write(data);

} catch (IOException e) {
    e.printStackTrace();

} finally {
    try {
        if (null != writer) {
            writer.close();
        }

    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

#### 从文件读取

`Context` 类中提供了一个 `openFileInput(String)` 方法，用于从文件中读取数据。该方法回一个 `FileInputStream` 对象。 `String` 参数是要读取的文件名，系统会自动到 `/data/data/<package-name>/files/` 目录下加载这个文件。

```java
try {
    FileInputStream in = openFileInput("data");
    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
    String line = "";
    while (null != (line = reader.readLine())) {
        content.append(line);
    }

} catch (IOException e) {
    e.printStackTrace();

} finally {
    if (null != reader) {
        try {
            reader.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### SharedPerferences 存储

`SharedPreferences` 使用键值对的方式来存储数据。

#### 获取 SharedPerferences 对象

使用 `SharedPreferences` ，需要获取到 `SharedPreferences` 对象。

- `Context` 中 `getSharedPreferences(String, int)` 方法

    `String` 参数用于指定 SharedPreferences 的文件名，如果文件不存在则会创建一个。 SharedPreferences 文件存放在 `/data/data/<package-name>/shared_prefs/` 目录下。 `int` 参数用于指定操作模式，目前只有 `MODE_PRIVATE` 这一种模式可选，表示只有当前的应用程序可以对这个 SharedPreferences 文件进行读写。其他模式已经废弃。

- `Activity` 中 `getPreferences(int)` 方法

    `int` 参数用于指定操作模式。该方法会自动将当前 Activity 的类名作为 SharedPreferences 的文件名。

- `PreferenceManager.getDefaultSharedPreferences(Context)` 静态方法

    `Context` 参数为当前程序上下文。该方法自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。

#### 写入到 SharedPerferences

1. 调用 `SharedPreferences` 对象的 `edit()` 方法获取 `SharedPreferences.Editor` 对象。
2. 向 `SharedPreferences.Editor` 对象中添加数据。可以通过以下方法。第一个参数均为 key ，第二个参数为 value 。

    - `putString(String, String)`
    - `putStringSet(String, Set<String>)`
    - `putInt(String, int)`
    - `putLong(String, long)`
    - `putFloat(String, float)`
    - `putBoolean(String, boolean)`

3. 调用 `apply()` 方法将添加的数据提交。

#### 从 SharedPerferences 读取

`SharedPreferences` 对象中提供了一系列的读取方法，用于对存储的数据进行读取。这些方法第一个参数均为 key ，第二个参数为 defValue ，默认值。表示当传入的键找不到对应的值时的返回值。

- `getString(String, String)`
- `getStringSet(String, String<String>)`
- `getInt(String, int)`
- `getLong(String, long)`
- `getFloat(String, float)`
- `getBoolean(String, boolean)`

### SQLite 数据库存储

`SQLite` 是一款轻量级的关系型数据库。它的运算速度非常快，占用资源很少，通常只需要几百 KB 的内存就足够了，因而特别适合在移动设备上使用。

Android 提供了一个 `SQLiteOpenHelper` 帮助类对数据库进行创建和升级。 `SQLiteOpenHelper` 是一个抽象类，需要创建一个自己的帮助类去继承它。 `SQLiteOpenHelper` 有两个构造方法可重写，一般使用 `SQLiteOpenHelper(Context, String, CursorFactory, int)` 。 `Context` 是当前程序上下文。 `String` 是数据库名。`CursorFactory` 允许我们在查询数据的时候返回一个自定义的 `Cursor` ，一般传入 `null` 。 `int` 是当前数据库的版本号，可用于对数据库进行升级操作。 `SQLiteOpenHelper` 中需要重写两个抽象方法 `onCreate(SQLiteDatabase)` 和 `onUpgrade(SQLiteDatabase, int, int)` ，在这两个方法中去实现创建和升级数据库的逻辑。

#### 创建数据库

创建 `SQLiteOpenHelper` 对象后，调用它的 `getReadableDatabase()` 或 `getWritableDatabase()` 方法即可创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则创建一个新的数据库），并返回一个 `SQLiteDatabase` 对象。不同的是，当数据库不可写入的时候（如磁盘空间已满）， `getReadableDatabase()` 方法返回的对象将以只读的方式去打开数据库，而 `getWritableDatabase()` 方法则将出现异常。数据库文件会存放在 `/data/data/<package-name>/databases/` 目录下。如果创建一个新的数据库，会执行重写的 `onCreate(SQLiteDatabase)` 方法。我们通常在这里处理创建表的逻辑。我们可以把 SQL 建表语句定义成一个字符串常量，然后在 `onCreate(SQLiteDatabase)` 方法中调用 `SQLiteDatabase` 对象的 `execSQL()` 方法去执行这条建表语句。

#### 升级数据库

当数据库已存在，而我们又想修改数据库结构时，我们可以使用 `onUpgrade(SQLiteDatabase, int, int)` 方法。在创建 `SQLiteOpenHelper` 对象时，版本号参数传一个比当前版本号大的值然后打开数据库，会执行 `onUpgrade(SQLiteDatabase, int, int)` 方法。我们通常在这里处理升级表的逻辑。 `SQLiteDatabase` 参数是可对数据库进行读写操作的对象。第一个 `int` 参数是旧的数据库版本。第二个 `int` 参数是新的数据库版本。我们可以把 SQL 升级语句定义成一个字符串常量，然后在 `onUpgrade(SQLiteDatabase, int, int)` 方法中根据数据库的新旧版本号调用 `SQLiteDatabase` 对象的 `execSQL()` 方法去执行这条升级语句。

#### 增

调用 `SQLiteOpenHelper` 的 `getReadableDatabase()` 或 `getWritableDatabase()` 方法会返回一个 `SQLiteDatabase` 对象，其中提供了 `insert(String, String, ContentValues)` 方法用于添加数据。第一个 `String` 参数是要添加数据的表名。第二个 `String` 参数用于在未指定添加数据的情况下给某些可为空的列自动赋值 `NULL` ，一般直接传入 `null` 即可。 `ContentValues` 参数是一个 `ContentValues` 对象，它提供了一系列的方法重载用于向 `ContentValues` 中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。这些方法的第一个参数为表的列名，第二个参数为对应的数据。

- `put(String, Boolean)`
- `put(String, Byte)`
- `put(String, byte[])`
- `put(String, Double)`
- `put(String, Float)`
- `put(String, Integer)`
- `put(String, Long)`
- `put(String, Short)`
- `put(String, String)`

#### 删

`SQLiteDatabase` 对象提供了 `delete(String, String, String[])` 方法用于删除数据。 第一个 `String` 参数是要删除数据的表名。第二个 `String` 和第三个 `String[]` 参数用于约束删除某一行或某几行中的数据，不指定的话默认删除所有行。

#### 改

`SQLiteDatabase` 对象提供了 `update(String, ContentValues, String, String[])` 方法用于更新数据。 第一个 `String` 参数是要更新数据的表名。 `ContentValues` 参数是 `ContentValues` 对象，组装要更新数据。第三个 `String` 和第四个 `String[]` 参数用于约束更新某一行或某几行中的数据，不指定的话默认更新所有行。

#### 查

`SQLiteDatabase` 对象提供了 `query()` 方法用于查询数据。这个方法十分复杂，有四种重载，用的较多的是 `query(String, String[], String, String[], String, String, String)` 。这个方法有七个参数。第一个参数 `table` 指定查询的表名。 第二个参数 `columns` 指定查询的列名。第三个 `selection` 指定 where 的约束条件参数。第四个参数 `selectionArgs` 为 where 中的占位符提供具体的值。第五个参数 `groupBy` 指定需要 groupby 的列。第六个参数 `having` 对 groupby 后的结果进一步约束。第七个参数 `orderBy` 指定查询结果的排序方式。该方法返回一个 `Cursor` 对象，查询到的所有数据都将从这个对象中取出。

#### 使用 SQL 语句

`SQLiteDatabase` 对象提供了直接处理 SQL 语句的方法。增删改时可以使用 `execSQL()` 方法，查询时可以使用 `rawQuery()` 方法。

### LitePal 操作数据库

`LitePal` 是一款开源的 Android 数据库框架，它采用了对象关系映射（ORM）的模式，并将常用的数据库功能进行了封装，不用编写SQL语句就可以完成各种建表和増删改查的操作。

[LitePal](https://github.com/LitePalFramework/LitePal)

#### 配置 LitePal

1. 编辑 `app/build.gradle` 文件，添加依赖项。

    ```groovy
    dependencies {
        compile 'org.litepal.android:core:1.6.0'
    }
    ```

2. 在 `app/src/main` 创建一个 `assets` 目录，然后在 `assets` 目录下新建一个 `litepal.xml` 文件。其中， `<dbname>` 标签用于指定数据库名， `<version>` 标签用于指定数据库版本号， `<list>` 标签用于指定所有的映射模型。

    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <litepal>
        <dbname value="dbName"/>
        <version value="1"/>
        <list></list>
    </litepal>
    ```

3. 配置 LitePalApplication 。修改 `AndroidManifest.xml` 中的代码，将项目的 application 配置为 `org.litepal.LitePalApplication` 。

```xml
<application
    android:name="org.litepal.LitePalApplication"
    ...>
</application>
```

#### LitePal 创建数据库

1. 定义实体类

    创建实体类，继承自 `DataSupport` 类。定义字段成员变量，并生成相应的 `getter()` 和 `setter()` 方法。

2. 将实体类添加到映射模型列表， `litepal.xml` 文件。使用完整的类名。

    ```xml
    <list>
        <mapping class="[model path]"/>
    </list>
    ```

此时只要进行任意一次数据库操作，相应的数据库就会自动创建出来。调用 `LitePal.getDatabase()` 方法就是一次最简单的数据库操作。

#### LitePal 升级数据库

使用 LitePal 升级数据库非常简单，完全不用思考任何逻辑。只需要修改任意需要的内容，然后将版本号加 1 。

#### LitePal 增

创建实体类的对象，将所有数据设置好，最后调用 `save()` 方法就可以了。

<h4 id="lp_del">LitePal 删</h4>

- 对已存储对象，调用 `delete()` 方法。

    对象是否已存储根据 `isSaved()` 方法的结果来判断，返回 `true` 表示已存储，返回 `false` 表示未存储。在两种情况下 `isSaved()` 方法会返回 `true` ，一种情况是已经调用过 `save()` 方法了，此时 model 会被认为是已存储的对象。另一种情况是 model 对象是通过 LitePal 提供的查询 API 查出来的，由于是从数据库中查到的对象，因此也会被认为是已存储的对象。

- 调用 `DataSupport.deleteAll(Class, String...)` 方法。

    `Class` 用于指定删除数据的表。 `String...` 参数用于指定约束条件。如果不指定约束条件，则删除表中所有的数据。

#### LitePal 改

更新数据 API 接口比较多，最常用的几种更新方式如下。

- 对已存储的对象重新设置数据，然后调用 `save()` 方法。

    对象是否已存储见[LitePal 删](#lp_del)章节。

- 新建实体类对象，设置更新的数据，调用 `updateAll(Class, String...)` 方法执行更新操作。

    `Class` 用于指定更新数据的表。 `String...` 参数用于指定约束条件。如果不指定条件语句，就表示更新所有数据。

    当需要把一个字段的值更新成默认值时，不可以使用上面的方式来设置数据。在 Java 中任何一种数据类型的字段都有默认值，当新建出一个实体类对象时，其实所有字段都已经被初始化成默认值了。如果我们调用 `set()` 方法将已经被初始化的字段设置为默认值， LitePal 此时不会对这个列进行更新。对于所有想要将为数据更新成默认值的操作， LitePal 统一提供了一个 `setToDefault(String)` 方法，参数传入相应的列名就可以了。

#### LitePal 查

- 调用 `DataSupport.findAll(Class, long...)` 方法。

    `Class` 用于指定查询数据的表。 `long...` 参数用于指定约束条件。如果不指定条件约束，就表示查询所有数据。 `findAll(Class, long...)` 方法返回一个传入的 Class 类型的 `List` 集合。

- 调用 `DataSupport.findFirst(Class)` 方法。

    查询表中的第一条数据。 `Class` 用于指定查询数据的表。

- 调用 `DataSupport.findlast(Class)` 方法。

    查询表中的最后一条数据。 `Class` 用于指定查询数据的表。

- 链式调用，组合查询。

  - `DataSupport.select(String...)`

    用于指定查询数据的列，传入 `null` 返回所有列。

  - `DataSupport.where(String...)`

    用于指定查询数据的约束信息，传入 `null` 返回所有数据。

  - `DataSupport.order(String)`

    用于指定结果的排序方式。参数使用 SQL 的 `ORDER BY` 语句， `desc` 表示降序排列， `asc` 或者不写表示升序排列。

  - `DataSupport.limit(int)`

    用于指定查询结果的数量。

  - `DataSupport.offset(int)`

    用于指定查询结果的偏移量。需要和 `DataSupport.limit(int)` 共同使用，否则不会返回数据。

  以上组合查询方法返回一个 `ClusterQuery` 对象。在完成组合后，调用 `find(Class)` 方法， `Class` 用于指定查询数据的表。该方法返回一个传入的 Class 类型的 `List` 集合。

- 使用原生 SQL 查询。

    调用 `DataSupport.findBySQL(String...)` 方法， `String...` 为 SQL 语句条件约束。

[↑目录](#index)

------

<h2 id="chap7">第7章 Content Provider</h2>

`ContentProvider` 用于实现程序间数据共享。它提供了一套允许程序间共享数据的完整的机制，同时还能保证被访数据的安全性。 `Content Provider` 是 Android 实现跨程序数据共享的标准方式。

### 运行时权限

传统 Android 的权限机制需要在 `AndroidManifest.xml` 文件中添加权限声明。这样，在安装该程序时会在安装界面列出该程序申请了哪些权限，可以让用户决定是否要安装这个程序。但是，通常用户不会因为不认同某些权限而拒绝安装应用。因此， Android 中加入了运行时权限功能。用户不需要在安装软件的时候一次性授权所有权限，而是可以在软件的使用过程中对某一项权限申请进行授权。

而且，并不是所有权限都需要在运行时申请。Android 将所有的权限归成了三类，一类是普通权限，一类是危险权限，还有第三类特殊权限。普通权限指不会直接威胁用户安全和隐私的权限，系统会自动进行授权。危险权限表示可能会触及用户隐私或对设备安全性造成影响的权限。这部分权限申请必须要由用户手动点击授权才可以，否则程序无法使用相应的功能。特殊权限很少使用。

危险权限一共有 9 组 24 项。

- CALENDAR
  - READ_CALENDAR
  - WRITE_CALENDAR
- CAMERA
  - CAMERA
- CONTACTS
  - READ_CONTACTS
  - WRITE_CONTACTS
  - GET_CONTACTS
- LOCATION
  - ACCESS\_FINE_LOCATION
  - ACCESS\_COARSE_LOCATION
- MICROPHONE
  - RECORD_AUDIO
- PHONE
  - READ\_PHONE_STATE
  - CALL_PHONE
  - READ\_CALL_LOG
  - WRITE\_CALL_LOG
  - ADD_VOICEMAIL
  - USE_SIP
  - PROCESS\_OUTGOING_CALLS
- SENSORS
  - BODY_SENSORS
- SMS
  - SEND_SMS
  - RECEIVE_SMS
  - READ_SMS
  - RECEIVE\_WAP_PUSH
  - RECEIVE_MMS
- STORAGE
  - READ\_EXTERNAL_STORAGE
  - WRITE\_EXTERNAL_STORAGE

每个危险权限都属于一个权限组。进行运行时授权时使用的是权限名，用户一旦同意授权，该权限所对应的权限组中所有的权限会同时被授权。

查看Android系统中完整的[权限列表](http://developer.android.google.cn/reference/android/Manifest.permission.html)。

#### 运行时权限申请

1. 判断授权状态

    借助 `ContextCompat.checkSelfPermission(Context, String)` 方法。 `Context` 参数是当前程序上下文， `String` 参数是权限名的字符串。该方法若返回 `PackageManager.PERMISSION_GRANTED` 则说明用户已授权，否则需要请求授权。

2. 申请授权

    调用 `ActivityCompat.requestPermissions(Activity, String[], int)` 方法。 `Activity` 参数是当前 Activity 的对象。 `String[]` 参数是要申请的权限名数组。 `int` 参数是请求码，用来在回调中判断请求来源，需要是唯一值。

3. 处理授权结果回调

    调用申请授权方法之后，系统会弹出权限申请对话框，用户可以选择同意或拒绝权限申请。结果会回调到 `onRequestPermissionsResult(int, String[], int[])` 方法中。 `int` 参数是调用申请授权方法时传入请求码，依此判断请求来源。 `String[]` 参数是本次申请的权限名数组。 `int[]` 参数是授权的结果，若某项值为 `PackageManager.PERMISSION_GRANTED` 则说明用户同意该项授权请求。

### ContentResolver

通过 `Context` 中的 `getContentResolver()` 获取到 `ContentResolver` 对象。 `ContentResolver`中提供了一系列方法用于对数据进行操作。

- `insert(Uri, ContentValues)`

    添加数据。 `Uri` 是数据路径。 `ContentValues` 是封装好的待添加数据。

- `delete(Uri, String, String[])`

    删除数据。 `Uri` 是数据路径。第二个 `String` 和第三个 `String[]` 参数用于约束删除。

- `update(Uri, ContentValues, String, String[])`

    修改数据。 `Uri` 是数据路径。 `ContentValues` 是封装好的待新数据。 第三个 `String` 和第四个 `String[]` 参数用于约束更新。

- `query(Uri, String[], String, String[], String)`

    查询数据。 `Uri` 是数据路径。第二个参数 `String[]` 指定查询的列名。第三个参数 `String` 指定 `WHERE` 的约束条件。第四个参数 `String[]` 为 `WHERE` 中的占位符提供具体的值。第五个参数 `String` 指定查询结果的排序方式。

URI 给 Content Provider 中的数据建立了唯一标识符，它主要由两部分组成： `authority` 和 `path` 。 `authority` 用于对不同的程序做区分，一般采用程序包名。 `path` 用于区分同一应用程序中不同的表。把 `authority` 和 `path` 组合，然后在字符串的头部加上协议声明。 URI 最标准的格式写法如下：

```text
content://[authority]/[path]
```

在得到了 URI 字符串之后，还需要通过 `Uri.parse(String)` 将它解析成 `Uri` 对象才可以作为参数传入。

```java
String URI_STRING = "content://[authority]/[path]";
Uri uri = Uri.parse(URI_STRING);
```

### 自定义 Content Provider

新建类继承 `android.content.ContentProvider` ，重写其中的抽象方法。

- `boolean onCreate()`

    初始化 Content Provider 时调用，通常在这里完成数据库的创建和升级等操作。返回 `true` 表示初始化成功，返回 `false` 则表示失败。

- `Uri insert(Uri, ContentValues)`

    向 Content Provider 添加一条数据。 `Uri` 参数确定要添加到的表。 `ContentValues` 保存待添加的数据。添加操作完成后，返回一个用于表示这条新记录的 `Uri` 。

- `int delete(Uri, String, String[])`

    从 Content Provider 删除数据。 `Uri` 参数确定要删除数据的表。第二个 `String` 和第三个 `String[]` 参数用于约束删除。返回被删除的行数。

- `int update(Uri, ContentValues, String, String[])`

    更新 Content Provider 已有的数据。 `Uri` 参数确定要更新数据的表。 `ContentValues` 是封装好的待新数据。 第三个 `String` 和第四个 `String[]` 参数用于约束更新。返回受影响的行数。

- `Cursor query(Uri, String[], String, String[], String)`

    从 Content Provider 中查询数据。 `Uri` 参数确定要查询数据的表。第二个参数 `String[]` 指定查询的列名。第三个参数 `String` 指定 `WHERE` 的约束条件。第四个参数 `String[]` 为 `WHERE` 中的占位符提供具体的值。第五个参数 `String` 指定查询结果的排序方式。查询的结果存放在 `Cursor` 对象中返回。

- `String getType(Uri)`

    根据传入的 `Uri` 参数返回相应的 MIME 类型。

现在，我们需要对传入的 `Uri` 参数进行解析，从中分析出调用方期望访问的表和数据。

Uri 由 `协议` ， `authority` 和 `path` 组成，还可以加一个 `id` 。

```text
content://[authority]/[path]/[id]
```

以 `path` 结尾表示期望访问表中所有的数据，以 `id` 结尾表示期望访问表中拥有相应 id 的数据。我们可以使用通配符的方式来分别匹配这两种格式的 Uri ，规则如下：

- `*`

    表示匹配任意长度的任意字符。

- `#`

    表示匹配任意长度的数字。

借助 `UriMatcher` 类就可以实现匹配 Uri 的功能。使用 `UriMatcher(int)` 构造 `UriMatcher` 对象，参数传入 `UriMatcher.NO_MATCH` 。然后调用 `addURI(String, String, int)` 方法添加期望匹配的内容。第一个 `String` 参数是 `authority` 。第二个参数 `String` 是 `path` 。第三个 `int` 参数是匹配该项成功时的返回值。在需要进行匹配时，调用 `match(Uri)` 方法传入需要进行匹配的 Uri 。若匹配成功，则返回相应的返回值。

Uri 对应的 MIME 字符串由 3 部分组成， Android 对这 3 部分做了格式规定：

- 必须以 `vnd` 开头。
- 如果 Uri 以 `path` 结尾，则后接 `android.cursor.dir/` ，如果 Uri 以 `id` 结尾，则后接 `android.cursor.item/` 。
- 最后接上 `vnd.[authority].[path]`。

最后，还需要在 `AndroidManifests.xml` 中注册自定义 Content Provider 。在 `<application>` 标签内添加标签 `<provider>`。标签内添加 `android:name` 属性指定自定义 Content Provider 的类名， `android:authorities` 属性指定 authority ， `enabled` 属性指定是否启用这个 Content Provider ， `exported` 属性指定是否允许这个 Content Provider 被其他应用程序访问。

[↑目录](#index)

------

<h2 id="chap8">第8章 多媒体</h2>

### 通知

当某个应用程序希望向用户发出一些提示信息，而该应用程序又不在前台运行时，就可以借助通知来实现。发出一条通知后，手机最上方的状态栏中会显示一个通知的图标，下拉状态栏后可以看到通知的详细内容。

1. 获取 `Notification Manager`

    调用 `Context` 的 `getSystemService(String)` 方法获取 `Notification Manager` 。 `String` 参数用于确定获取系统的哪个服务，这里需要传入 `Context.NOTIFICATION_SERVICE` 。

    ```java
    NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
    ```

2. 创建 `Notification` 对象

    使用 `Builder` 构造器来创建 `Notification` 对象。建议使用 support 库中的兼容 API 。其中提供了丰富的 API 来创建多样的通知效果。

    - `setContentTitle(String)`

        用于指定通知的标题内容。

    - `setContentText(String)`

        用于指定通知的正文内容。

    - `setWhen(long)`

        用于指定通知被创建的时间，以毫秒为单位。

    - `setSmallIcon(int)`

        用于设置通知的小图标，只能使用纯 alpha 图层的图片进行设置，小图标会显示在系统状态栏上。

    - `setLargeIcon(Bitmap)`

        用于设置通知的大图标。

    - `setContentIntent(PendingIntent)`

        用于设置用户点击通知的逻辑。接收一个 `PendingIntent` 参数。

        `PendingIntent` 提供了几个静态方法用于获取对象。可以根据需求来选择 `getActivity(Context, int, Intent, int)` ， `getBroadcast(Context, int, Intent, int)` 还是 `getService(Context, int, Intent, int)` 方法。这几个方法所接收的参数都是相同的，第一个 `Context` 参数传入上下文。第二个 `int` 参数是请求码，传入唯一即可。第三个 `Intent` 参数是构建 PendingIntent 的意图。第四个 `int` 参数用于确定 PendingIntent 的行为，有以下值可选：

        - FLAG\_ONE_SHOT

            获取的 PendingIntent 只能使用一次。

        - FLAG\_NO_CREATE

            若描述的 Intent 不存在则返回 `null` 值。

        - FLAG\_CANCEL_CURRENT

            如果描述的 PendingIntent 已经存在，则产生新的 Intent 之前会先取消掉当前的。

        - FLAG\_UPDATE_CURRENT

            如果描述的 PendingIntent 已经存在，则使用新 Intent 中的数据替换当前的。

        - FLAG_IMMUTABLE

            获取的 PendingIntent 不能被更改。

    - `setAutoCancel(boolean)`

        用于设置点击通知的时候，通知是否会自动取消。

    - `setSound(Uri)`

        用于设置通知发出时候播放的音频。该方法接收一个 `Uri` 参数，传入指定音频文件对应的 Uri 。

    - `setVibrate(long[])`

        用于设置通知发出时候手机的震动。该方法接收一个 `long[]` 数组，数组中的值为静止时长，震动时长交替。

        控制手机振动需要声明权限。在 `AndroidManifest.xml` 中加入如下权限声明：

        ```xml
        <uses-permission android:name="android.permission.VIBRATE"/>
        ```

    - `setLights(int, int, int)`

        用于控制前置 LED 的闪烁。该方法接收 3 个参数，第一个 `int` 参数用于指定 LED 的颜色。第二个 `int` 参数用于指定 LED 亮起的时长，以毫秒为单位。第三个 `int` 参数用于指定 LED 暗去的时长，以毫秒为单位。

    - `setDefaults(int)`

        使用通知的默认效果。可以使用以下值进行按位或：

        - NotificationCompat.DEFAULT_SOUND

            使用默认的通知声音。会忽略 `setSound(Uri)` 方法设置的声音。

        - NotificationCompat.DEFAULT_VIBRATE

            使用默认的震动效果。会忽略 `setVibrate(long[])` 方法设置的震动效果。

        - NotificationCompat.DEFAULT_LIGHTS

            使用默认的前置 LED 效果。会忽略 `setLights(int, int, int)` 方法设置的前置 LED 效果。

        - NotificationCompat.DEFAULT_ALL

            全部使用默认效果。

    - `setStyle(Style)`

        用于构建富文本通知内容。该方法接收 `NotificationCompat.Style` 参数，这个参数用来构建具体的富文本信息，如长文字、图片等。 `NotificationCompat.Style` 是抽象的，需要使用它的实现类。

    - `setPriority(int)`

        用于设置通知的重要程度。该方法接收一个 `int` 参数，一共有5个常量值可选：

        - `PRIORITY_MAX`

            表示最高的重要程度，这类通知消息必须要让用户立刻看到，甚至需要用户做出响应操作。

        - `PRIORITY_HIGH`

            表示较高的重要程度，系统可能会将这类通知放大，或改变其显示的顺序，将其排在比较靠前的位置。

        - `PRIORITY_DEFAULT`

            表示默认的重要程度，和不设置效果是一样的。

        - `PRIORITY_LOW`

            表示较低的重要程度，系统可能会将这类通知缩小，或改变其显示的顺序，将其排在更重要的通知之后。

        - `PRIORITY_MIN`

            表示最低的重要程度，系统可能只会在特定的场景才显示这条通知，比如用户下拉状态栏的时候。

3. 显示通知

    调用 `Notification Manager` 的 `notify(int, Notification)` 方法可以显示通知。第一个 `int` 参数用于指定通知的 id ，要保证唯一性。第二个 `Notification` 参数传入创建好的 `Notification` 对象。

4. 手动取消通知

    调用 `Notification Manager` 的 `cancel(int)` 方法可以手动取消通知。 `int` 参数用于指定通知的 id ，传入显示通知时指定的唯一 id 。调用 `cancelAll()` 方法可以取消该程序显示的全部通知。

### 调用摄像头

1. 创建 `File` 对象

    用于存放摄像头拍下的图片。命名图片并将它存放在 SD 卡的应用关联缓存目录下，该目录的路径是 `/sdcard/Android/data/<package-name>/cache` ，可以通过调用 `getExternalCacheDir()` 方法得到。使用应用关联缓存目录可以避免进行运行时权限处理。

2. 获取 `File` 对象的 Uri

    首先判断当前版本。如果当前 API 版本小于 `24` ，就调用 `Uri.fromFile(File)` 方法将 `File` 对象转换成 `Uri` 对象，这个对象标识着图片的本地真实路径。否则，就调用 `FileProvider.getUriForFile(Context, String, File)` 方法将 `File` 对象转换成一个封装过的 `Uri` 对象。该方法接收 3 个参数，第一个 `Context` 参数传入上下文对象。第二个 `String` 参数传入 `AndroidManifests.xml` 中定义的 authority 字符串。第三个 `File` 参数传入图片对象。从 Android 7.0 系统开始，直接使用本地真实路径的 Uri 被认为是不安全的，会抛出一个 `FileUriExposedException` 异常。而 `FileProvider` 是一种特殊的 Content Provider ，它使用了和 Content Provider 类似的机制对数据进行保护，可以选择性地将封装过的 Uri 共享给外部，从而提高了应用的安全性。

3. 注册 Content Provider

    在 `AndroidManifests.xml` 中的 `<Application>` 标签下添加以下内容：

    ```xml
    <provider android:name="android.support.v4.content.FileProvider"
        android:authorities="[authority]"
        android:exported="false"
        android:grantUriPermissions="true">
        <meta-data
            android:name="android.support.FILE_PROVIDER_PATHS"
            android:resource="@xml/file_paths"/>
    </provider>
    ```

    `android:authorities` 属性中定义一个独特的 authority 字符串，用来传入`FileProvider.getUriForFile(Context, String, File)` 方法。 `<meta-data>` 标签下的 `android:resource` 属性引用了一个 `@xml/file_paths` 资源。在模块的 `res` 目录下创建 `xml` 文件夹，并在其中创建一个 `file_paths.xml` 文件，添加以下内容：

    ```xml
    <?xml version="1.0" encoding="utf- 8"?>
    <paths xmlns:android="http://schemas.android.com/apk/res/android">
        <external-path
            name="[name]"
            path="[path]"/>
    </paths>
    ```

    其中， `<external-path>` 标签用来指定 Uri 共享， `name` 属性可以指定名称， `path` 属性指定共享的具体路径。这里置空表示共享整个 SD 卡，也可以仅指定存放图片的路径。

    在 API 19 之前，访问 SD 卡应用关联目录也需要要声明权限。如需兼容，添加：

    ```xml
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    ```

4. 构建 `Intent` 对象

    构建隐式 `Intent` 对象，将其 `action` 指定为 `android.media.action.IMAGE_CAPTURE` ，再调用 `putExtra(String, String)` 方法指定图片的输出地址，其中 key 传入 `MediaStore.EXTRA_OUTPUT` ， value 传入 Uri 对象。

5. 开启相机

    使用 `startActivityForResult(Intent, int)` 来开启相机。拍摄的照片将会存储到我们指定的文件中。

6. 处理回调

    拍照完成后返回结果到 `onActivityResult(int, int, Intent)` 方法中，根据 `requestCode` 和 `resultCode` 判断结果。如果拍照成功，可以调用 `BitmapFactory.decodeStream(InputStream)` 方法将图片文件解析为 `Bitmap` 对象。

### 调用相册

1. 运行时权限处理

    动态申请 `WRITE\_EXTERNAL_STORAGE` 权限，使程序获得读写 SD 卡的能力。

2. 构建 Intent 对象

    构建隐式 `Intent` 对象，将其 `action` 指定为 `android.intent.action.GET_CONTENT` ，再调用 `setType(String)` 方法指定 MIME 类型。

3. 开启相册

    使用 `startActivityForResult(Intent, int)` 来开启相册。

4. 处理回调

    选择完成后返回结果到 `onActivityResult(int, int, Intent)` 方法中，根据 `requestCode` 和 `resultCode` 判断结果执行逻辑。首先判断当前版本，如果当前 API 版本小于 `19` ，直接使用 Uri 即可获得图片对象。如果当前 API 版本大于等于 `19` ，选取相册中的图片不再返回真实的 Uri ，而是一个封装过的 Uri ，需要对这个 Uri 进行解析。

### 播放音频

Android 中播放音频使用 `MediaPlayer` 类实现。以下为 `MediaPlayer` 类中一些常用控制方法。

- `setDataSource(String)`

    设置要播放的音频文件。该方法有多种重载。

- `prepare()`

    在开始播放前调用，完成准备工作。

- `start()`

    开始或继续播放音频。

- `pause()`

    暂停播放音频。

- `reset()`

    重置 `MediaPlayer` 对象到刚刚创建的状态。

- `seekTo(int)`

    从指定的位置开始播放音频。接收一个 `int` 参数，单位是毫秒。

- `stop()`

    停止播放音频。调用这个方法后的 `MediaPlayer` 对象无法再播放音频。

- `release()`

    释放与 `MediaPlayer` 对象相关的资源。

- `isPlaying()`

    判断当前 MediaPlayer 是否正在播放音频。

- `getDuration()`

    获取载入的音频文件的时长。

MediaPlayer 工作流程如下：首先创建 `MediaPlayer` 对象，然后调用 `setDataSource()` 方法设置音频文件。再调用 `prepare()` 方法使 MediaPlayer 进入准备状态。接下来调用 `start()` 方法可以开始播放音频，调用 `pause()` 方法会暂停播放，调用 `reset()` 方法会停止播放。

音频文件一般存储在 SD 卡中，使用 MediaPlayer 还需要进行运行时权限处理，动态申请 `WRITE_EXTERNAL_STORAGE` 权限。还需要在 `AndroidManifest.xml` 文件中声明用到的权限。

```xml
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
```

### 播放视频

Android 中播放视频使用 `VideoView` 类实现。以下为 `VideoView` 类中一些常用控制方法。

- `setVideoPath(String)`

    设置要播放的视频文件的位路径。

- `start()`

    开始或继续播放视频。

- `pause()`

    暂停播放视频。

- `resume()`

    将视频重头开始播放。

- `seekTo(int)`

    从指定的位置开始播放视频。接收一个 `int` 参数，单位是毫秒。

- `isPlaying()`

    判断当前是否正在播放视频。

- `getDuration()`

    获取载入的视频文件的时长。

- `suspend()`

    将 VideoView 所占用的资源释放掉。

[↑目录](#index)

------

<h2 id="chap9">第9章 网络</h2>

### WebView

Android 提供了 `WebView` 控件展示各种网页。

```xml
<WebView
    android:id="@+id/web_view"
    android:layout_width="match_parent"
    android:layout_height="match_parent"/>
```

调用 `getSettings()` 方法可以设置浏览器的属性，可以调用 `setJavaScriptEnabled(boolean)` 方法使其支持 JavaScript 脚本。调用 WebView 的 `setWebViewClient(WebViewClient)` 方法，该方法接收一个 `WebViewClient` 对象。其作用是当需要从一个网页跳转到另一个网页时，目标网页仍然在当前 WebView 中显示，而不是打开系统浏览器。调用 `loadUrl(String)` 方法，该方法接收一个 `String` 类型的网址，用于展示相应网页的内容。

```java
WebSettings settings = webView.getSettings();
settings.setJavaScriptEnabled(true);
webView.setWebViewClient(new WebViewClient());
webView.loadUrl("[URL]");
```

访问网络需要声明权限，在 `AndroidManifest.xml` 文件中加入权限声明。

```xml
<uses-permission android:name="android.permission.INTERNET"/>
```

### HttpUrlConnection

首先获取 `HttpURLConnection` 对象。需要新建一个 `URL` 对象，并传入目标网络地址。然后调用 `openConnection()` 方法即可。接下来，可以设置 HTTP 请求所使用的方法： `GET` 或 `POST` 。还可以通过 `setConnectTimeout(int)` 和 `setReadTimeout(int)` 设置设置连接超时和读取超时。之后调用 `getInputStream()` 方法可以获取服务器返回的输入流并对输入流进行读取。最后可以调用 `disconnect()` 方法关闭这个 HTTP 连接。

```java
HttpURLConnection connection = null;
BufferedReader reader = null;
try {
    URL url = new URL("[URL]");
    connection = (HttpURLConnection) url.openConnection();
    connection.setRequestMethod("GET");
    connection.setConnectTimeout(5000);
    connection.setReadTimeout(5000);
    InputStream in = connection.getInputStream();
    reader = new BufferedReader(new InputStreamReader(in));
    StringBuilder response = new StringBuilder();
    String line;
    while (null != (line = reader.readLine())) {
        response.append(line);
    }

    showResult(response);

} catch (Exception e) {
    e.printStackTrace();

} finally {
    if (null != reader) {
        try {
            reader.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    if (null != connection) {
        connection.disconnect();
    }
}
```

进行 HTTP 请求需要在子线程中进行，并且需要声明权限，在 `AndroidManifest.xml` 文件中加入权限声明。

```xml
<uses-permission android:name="android.permission.INTERNET"/>
```

如果想要提交数据到服务器，需要将 HTTP 请求的方法改成 `POST` ，并在获取输入流之前把数据写出即可。每条数据都要以键值对的形式存在，数据与数据之间用 `&` 符号隔开。

```java
connection.setRequestMethod("POST");
DataOutputStream out = new DataOutputStream(connection.getOutputStream());
out.writeBytes("key1=value1&key2=value2");
```

### OkHttp

OkHttp 由 Square 公司开发。 OkHttp 不仅在接口封装上做得简单易用，就连在底层实现上也是自成一派。现已成为 Android 开发首选网络通信库。

[OkHttp](https://github.com/square/okhttp)

编辑 `app/build.gradle` 文件，添加依赖项。

```groovy
dependencies {
    compile 'com.squareup.okhttp3:okhttp:3.9.0'
}
```

创建 `OkHttpClient` 对象

```java
OkHttpClient okHttpClient = new OkHttpClient();
```

创建 `Request` 对象，传入目标地址。

```java
Request request = new Request.Builder()
        .url("[URL]")
        .build();
```

使用 POST 方式发送请求，需要新建 `RequestBody` 对象存放待提交的参数。然后在 `Request.Builder` 中调用 `post(RequestBody)` 方法将其传入。

```java
RequestBody requestBody = new FormBody.Builder()
            .add("key1", "value1")
            .add("key2", "value2")
            .build();

Request request = new Request.Builder()
        .url("[URL]")
        .post(requestBody)
        .build();
```

调用 `OkHttpClient` 的 `newCall()` 方法创建 `Call` 对象，并调用的 `execute()` 方法发送请求并获取服务器返回的数据。

```java
Response response = okHttpClient.newCall(request).execute();
```

其中 `Response` 对象是服务器返回的数据，可以得到返回的具体内容。

```java
String responseData = response.body().toString();
```

### XML 解析

`XML` 是网络传输数据时常用的格式之一。

#### Pull

首先获取一个 `XmlPullParserFactory` 的实例，并借助这个实例得到 `XmlPullParser` 对象。然后调用 `XmlPullParser` 的 `setInput(Reader)` 方法将 XML 数据传入。接下来是解析的过程。通过 `getEventType()` 得到当前解析事件，然后在一个 while 循环中不断地进行解析。如果当前的解析事件不等于 `XmlPullParser.END_DOCUMENT` ，说明解析工作工作还没完成，调用 `next()` 方法后可以获取下一个解析事件。在 while 循环中，通过 `getName()` 方法得到当前节点的名字。如果发现节点名是我们需要的，就调用 `nextText()` 方法获取节点内的内容。

#### SAX

新建一个类继承自 `DefaultHandler` ，并重写父类的 5 个方法。

- `startDocument()`

    会在开始XML解析的时候调用。

- `startElement(String, String, String, Attributes)`

    会在开始解析某个节点的时候调用。

- `characters(char[], int, int)`

    方法会在获取节点中内容的时候调用。

- `endElement(String, String, String)`

    会在完成解析某个节点的时候调用。

- `endDocument()`

    会在完成整个XML解析的时候调用。

其中， `startElement(String, String, String, Attributes)` ， `characters(char[], int, int)` 和 `endElement(String, String, String)` 这3个方法有参数，从 XML 中解析出的数据会以参数的形式传入这些方法中。在获取节点中的内容时， `characters(char[], int, int)` 方法可能会被调用多次，一些换行符也被当作内容解析出来，我们需要针对这种情况在代码中做好控制。

### JSON 解析

比起 XML ， JSON 的主要优势在于它的体积更小，在网络上传输的时候可以更省流量。但缺点在于，它的语义性较差，看起来不如 XML 直观。

#### JSONObject

JSONObject 是官方提供的解析方法。

若服务器中定义的是 JSON 对象，则将 JSON 数据传入 `JSONObject` 对象中。若服务器中定义的是 JSON 数组，则将 JSON 数据传入 `JSONArray` 对象中。通过遍历 `JSONArray` 对象可以得到 `JSONObject` 对象。在 `JSONObject` 对象中可以通过 `get(String)` 方法，传入 key 值即可取出数据。

#### GSON

GSON 是 Google 提供的开源库。 GSON 可以将一段 JSON 格式字符串自动映射成一个对象。

[GSON](https://github.com/google/gson)

编辑 `app/build.gradle` 文件，添加依赖项。

```groovy
dependencies {
    compile 'com.google.code.gson:gson:2.8.2'
}
```

根据 JSON 中的字段定义模型类，然后调用 `Gson` 对象的 `fromJson(String, Class)` 方法就可以将 JSON 解析成对象了。

```java
Gson gson = new Gson();
gson.fromJson(jsonString, TargetObject.class);
```

如果需要解析的是 JSON 数组，我们需要借助 `TypeToken` 将期望解析数据类型传入到 `fromJson(String, Type)` 方法中。

```java
Gson gson = new Gson();
List<TargetObject> people = gson.fromJson(jsonString, new TypeToken<List<TargetObject>>(){}.getType());
```

[↑目录](#index)

------

<h2 id="chap10">第10章 Service</h2>

`Service` 是 Android 中实现程序后台运行的解决方案，它适合执行不需要和用户交互但要求长期运行的任务。 Service 的运行不依赖于用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。需要注意的是，服务并不是运行在一个独立的进程当中的，而是依赖创建服务时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的服务也会停止运行。另外，服务并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞住的情况。

### 多线程

定义一个线程需要新建一个类继承自 `Thread` ，然后重写父类的 `run()` 方法，并在里面编写耗时逻辑。然后新建其对象，调用它的 `start()` 方法即可在新的线程中执行。

```java
class SubThread extends Thread {
    @Override
    public void run() {
        // 执行的逻辑
    }
}

new SubThread().start();
```

还可以使用 `Runnable` 接口方式开启子线程。定义一个类实现 `Runnable` 接口。 `Thread` 的构造函数接收一个 `Runnable` 参数，传入新建的自定义对象。接着调用 `Thread` 的 `start()` 方法， `run()` 方法中的代码就会在子线程当中运行。

```java
class SubThread implements Runnable {
    @Override
    public void run() {
        // 执行的逻辑
    }
}

// 在方法内：
SubThread subThread = new SubThread();
new Thread(subThread).start();
```

还可以使用匿名内部类的方式。

```java
new Thread(new Runnable() {
    @Override
    public void run() {
        // 执行的逻辑
    }
}).start();
```

#### 子线程更新 UI

Android 的 UI 是线程不安全的。如果想要更新应用程序里的 UI 元素，必须在主线程中进行，否则就会出现异常。

先定义一个整型常量，用于判断 `Message` 的动作类型。然后新建一个 `Handler` 对象，并重写父类的 `handleMessage()` 方法。在这里对具体的 `Message` 进行处理，根据 `Message` 的 `what` 字段与自定义的整形常量对比以判断动作类型，并执行相应逻辑。在需要执行操作的位置创建一个 `android.os.Message` 对象，并将它的 `what` 字段的值指定为对应的自定义整形常量。然后调用 `Handler.sendMessage(Message)` 方法将这条 `Message` 发送出去。很快， `Handler` 就会收到这条 `Message` ，并在 `handleMessage()` 方法中对它进行处理。此时handleMessage()方法中的代码就是在主线程当中运行的了，所以我们可以放心地在这里进行UI操作。

```java
public static final int FLAG_ACTION = 1;

private Handler handler = new Handler(){
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case FLAG_ACTION:
                // 更新 UI 操作
                break;

            default:
                break;
        }
    }
};

// 在方法内：
new Thread(new Runnable() {
    @Override
    public void run() {
        Message message = new Message();
        message.what = FLAG_ACTION;
        handler.sendMessage(message);
    }
}).start();
```

#### 异步消息处理机制

Android 中的异步消息处理由 4 个部分组成：

- Message

    `Message` 是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。除了 `Message` 的 `what` 字段，还可以使用 `arg1` 和 `arg2` 字段来携带一些整型数据，使用 `obj` 字段携带一个 `Object` 对象。

- Handler

    `Handler` 是处理者的意思，它主要用于发送和处理消息。发送消息一般使用 `Handler` 的 `sendMessage(Message)` 方法。发出的消息经过一系列处理后，最终会传递到 `Handler` 的 `handleMessage(Message)` 方法中。

- Message Queue

    `Message Queue` 是消息队列的意思，主要用于存放所有通过 `Handler` 发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个 `MessageQueue` 对象。

- Looper

    `Looper` 是每个线程中的 Message Queue 的管家，调用 `Looper.loop()` 方法后，就会进入一个循环。每当发现 Message Queue 中存在一条消息，就会将它取出，并传递到 `Handler` 的 `handleMessage(Message)` 方法中。每个线程中也只会有一个 `Looper` 对象。

#### AsyncTask

AsyncTask 基于异步消息处理机制的封装。

`AsyncTask` 是一个抽象类，我们必须创建一个子类继承它。在继承时我们可以为 `AsyncTask` 类指定 3 个泛型参数，用途如下：

- `Params`

    在执行 `AsyncTask` 时需要传入的参数，可用于在后台任务中使用。

- `Progress`

    后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。

- `Result`

    当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。

还需要重写 `AsyncTask` 中的几个方法才能完成对任务的定制。

- `onPreExecute()`

    这个方法会在后台任务开始执行之前调用，用于进行一些初始化操作。

- `doInBackground(Params...)`

    这个方法中的所有代码都会在子线程中运行，在这里处理耗时任务。一旦任务完成就可以通过 `return` 语句返回任务的执行结果。如果 `AsyncTask` 的第三个泛型参数指定的是 `void` ，则可以不返回任务执行结果。在这个方法中不可以进行 UI 操作。如果需要更新 UI 元素，可以调用 `publishProgress(Progress...)` 方法来完成。

- `onProgressUpdate(Progress...)`

    当在后台任务中调用了 `publishProgress(Progress...)` 方法后，`onProgressUpdate(Progress...)` 方法很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应的更新。

- `onPostExecute(Result)`

    当后台任务执行完毕并通过 `return` 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作。

### Service

#### 定义 Service

Service 的类需要继承自 `android.app.Service` ，必须重写其中的 `onBind(Intent)` 方法。其他常用的方法有 `onCreate()` ， `onStartCommand(Intent, int, int)` 和 `onDestroy()` 。 `onCreate()` 方法在 Service 创建时调用。 `onStartCommand(Intent, int, int)` 方法在每次 Service 启动时调用。 `onDestroy()` 方法在 Service 销毁时调用。 Service 需要在 `AndroidManifest.xml` 文件中进行注册才能生效。在 `<application>` 标签内添加新的标签 `<service>` 来注册 Service 。在 `<service>` 标签中添加 `android:name` 属性来指定注册的 Service 类名， `enabled` 属性指定是否启用这个 Service ， `exported` 属性指定是否允许这个 Service 被其他程序访问。

#### Service 启动和停止

在 `Context` 中有 `startService(Intent)` 和 `stopService(Intent)` 方法，分别用来启动和停止服务。除此之外，还可以在 Service 内调用 `stopSelf()` 方法停止服务。若开启了 Service ，则 Service 会一直处于运行状态。

```java
Intent intent = new Intent(context, TargetService.class);
startService(intent);
// ...
stopService(intent);
```

#### Activity 和 Service 通信

Activity 和 Service 之间通信可以通过 `Binder` 。自定义 Binder 类继承自 `android.os.Binder` ，在其内部定义 Activity 可以调用的相关功能。然后在 Service 中创建自定义 Binder 的对象，并在 `onBind(Intent)` 方法中返回该对象。在 Activity 中创建一个 `ServiceConnection` 的匿名内部类，重写其中的 `onServiceConnected(ComponentName, IBinder)` 和 `onServiceDisconnected(ComponentName)` 方法。这两个方法分别在 Activity 与 Service 成功绑定以及连接断开时调用。在 `onServiceConnected(ComponentName, IBinder)` 方法中，通过向下转型得到了自定义 Binder 的对象。现在我们可以在 Activity 中根据具体的场景来调用自定义 Binder 中的任何 public 方法。最后，将 Activity 和 Service 进行绑定。在 `Context` 中有 `bindService(Intent, ServiceConnection, int)` 和 `unbindService(ServiceConnection)` 方法，分别用来绑定和解绑。 `bindService(Intent, ServiceConnection, int)` 的第三个 `int` 参数一般传入 `BIND_AUTO_CREATE` 表示进行绑定后自动创建 Service 。这会使 Service 中的 `onCreate()` 方法得到执行，但 `onStartCommand(Intent, int, int)` 方法不会执行。

任何一个 Service 在整个应用程序范围内都是通用的，可以和任何一个 Activity 进行绑定，而且在绑定完成后它们都可以获取到相同的 Binder 对象。

#### Service 生命周期

一旦调用 `Context` 的 `startService(Intent)` 方法，相应的 Service 就会启动。若这个 Service 还没有创建过， `onCreate()` 方法和 `onStartCommand(Intent, int, int)` 方法会先后执行。否则，会直接回调 `onStartCommand(Intent, int, int)` 方法。服务启动之后会一直保持运行状态，直到 `stopService(Intent)` 或 `stopSelf()` 方法被调用。虽然每调用一次 `startService(Intent)` 方法， `onStartCommand()` 就会执行一次，但实际上每个服务都只会存在一个实例。所以不管调用了多少次 `startService(Intent)` 方法，只需调用一次 `stopService(Intent)` 或 `stopSelf()` 方法，服务就会停止。

另外，还可以调用 `Context` 的 `bindService(Intent, ServiceConnection, int)` 来获取一个服务的持久连接，这时就会回调服务中的 `onBind()` 方法。类似地，如果这个服务之前还没有创建过， `onCreate()` 方法会先于 `onBind()` 方法执行。之后，调用方可以获取到 `onBind()` 方法里返回的 `IBinder` 对象，这样就能和 Service 进行通信了。只要调用方和 Service 之间没有断开连接，服务就会一直保持运行状态。

当调用了 `startService(Intent)` 方法后，又调用 `stopService(Intent)` 方法，这时 Service 中的 `onDestroy()` 方法就会执行，表示服务已经销毁了。类似地，当调用了 `bindService(Intent, ServiceConnection, int)` 方法后，又调用 `unbindService(ServiceConnection)` 方法， `onDestroy()` 方法也会执行。对一个服务既调用了 `startService(Intent)` 方法，又调用了 `bindService(Intent, ServiceConnection, int)` 方法时，要同时调用 `stopService(Intent)` 和 `unbindService(ServiceConnection)` 方法， `onDestroy()` 方法才会执行。

![Service 生命周期](https://developer.android.google.cn/images/fundamentals/service_binding_tree_lifecycle.png "Service lifecycle")

#### 前台 Service

前台 Service 在系统状态栏有一个正在运行的图标显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。前台 Service 的系统优先级较高，可以防止由于系统 内存不足被回收。

在自定义 Service 的 `onCreate()` 方法中调用 `startForeground(int, Notification)` 方法。这个方法接收两个参数，第一个 `int` 参数是通知的 id 。第二个参数则是构建出的 `Notification` 对象。调用 `startForeground(int, Notification)` 方法后就会让自定义 Service 变成一个前台 Service ，并显示在系统状态栏。

#### IntentService

IntentService 是一个异步的、会自动停止的 Service 。

创建自定义 IntentService 类继承自 `android.app.IntentService` 。首先要提供一个无参的构造函数，并且必须在其内部调用父类的有参构造函数。然后在子类中去实现 `onHandleIntent(Intent)` 这个抽象方法。在这个方法中可以处理一些逻辑，这些逻辑在子线程中运行。最后需要在 `AndroidManifest.xml` 里注册 IntentService 。

IntentService 的启动和停止方式和 Service 相同。

[↑目录](#index)

------

<h2 id="chap11">第11章 定位</h2>

[百度 LBS](http://lbsyun.baidu.com/)

### 申请 API Key

[注册百度帐号](http://developer.baidu.com/user/reg) → 验证邮箱 → 创建应用 → 得到 API Key

### 下载 SDK

[下载 SDK](http://lbsyun.baidu.com/sdk/download) → 放入工程

### 进行定位

1. 添加权限声明

    ```xml
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/>
    <uses-permission android:name="android.permission.READ_PHONE_STATE"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/>
    <uses-permission android:name="android.permission.WAKE_LOCK"/>
    ```

2. 在 `<application>` 标签下添加 `<meta-data>` 标签

    ```xml
    <meta-data
        android:name="com.baidu.lbsapi.API_KEY"
        android:value="[API-Key]"/>
    ```

3. 注册 Service

    ```xml
    <service
        android:name="com.baidu.location.f"
        android:enabled="true"
        android:process=": remote"/>
    ```

4. 创建 `LocationClient` 对象

    创建一个 `LocationClient` 对象。 `LocationClient` 的构造函数接收一个 `Context` 参数。

5. 配置 LocationClient

    新建 `LocationClientOption` 对象。通过 `LocationClientOption` 对象中的一系列方法可以对定位行为进行配置。

    - `setScanSpan(int)`

        设置定位更新的间隔。单位为毫秒。不设置只会定位一次。

    - `setLocationMode(String)`

        指定定位的模式。可选模式： `LocationMode.Hight_Accuracy` ， `LocationMode.Battery_Saving` 和 `LocationMode.Device_Sensors` 。

    - `setIsNeedAddress(boolean)`

        设置是否获取当前位置详细的地址信息。

    最后调用 `LocationClient` 的 `setLocOption(LocationClientOption)` 方法添加配置。

6. 自定义 LocationListener

    自定义 LocationListener 实现 `BDLocationListener` 接口。重写 `onReceiveLocation(BDLocation)` 和 `onConnectHotSpotMessage(String, int)` 方法。在 `onReceiveLocation(BDLocation)` 方法中，可以通过 `BDLocation` 对象中的一系列方法可以获取定位信息。

    - `getLatitude()`

        获取定位的纬度信息。

    - `getLongitude()`

        获取定位的经度信息。

    - `getLocType()`

        获取当前的定位方式。

    - `getCountry()`

        获取当前所在的国家。需要 `setIsNeedAddress(true)` 。

    - `getProvince()`

        获取当前所在的省。需要 `setIsNeedAddress(true)` 。

    - `getCity()`

        获取当前所在的市。需要 `setIsNeedAddress(true)` 。

    - `getDistrict()`

        获取当前所在的区。需要 `setIsNeedAddress(true)` 。

    - `getStreet()`

        获取当前所在的街道。需要 `setIsNeedAddress(true)` 。

7. 注册自定义 LocationListener 对象

    创建自定义 LocationListener 对象。调用 `LocationClient` 的 `registerLocationListener(BDLocationListener)` 方法注册 LocationListener ，当获取到位置信息的时候，就会回调这个 LocationListener 。

8. 处理运行时权限

    首先创建一个 `List` 集合，然后依次判断 `ACCESS_COARSE_LOCATION` ， `READ_PHONE_STATE` 和 `WRITE_EXTERNAL_STORAGE` 这 3 个权限是否被授权。如果没被授权则添加到 `List` 集合中。最后将 `List` 转换为 `String[]` ，再调用 `ActivityCompat.requestPermissions(Activity, String[], int)` 方法一次性申请。在 `onRequestPermissionsResult(int, String[], int[])` 方法中通过循环将每个申请的权限进行判断，只有所有权限都被用户同意了，才能开始定位。

9. 开启和关闭定位

    调用 `LocationClient` 的 `start()` 方法即可开始定位。调用 `LocationClient` 的 `stop()` 方法可以停止定位。停止方法一定要调用，否则 Service 会持续在后台进行定位，从而严重消耗手机的电量。

### 使用地图

1. 放置 MapView

    在布局文件中放置 `MapView` 。

    ```xml
    <com.baidu.mapapi.map.MapView
        android:id="@+id/bmapView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clickable="true"/>
    ```

2. 初始化并获取对象

    调用 `SDKInitializer` 的 `initialize(Context)` 方法进行初始化操作。初始化操作一定要在 `setContentView()` 方法前调用，否则会出错。接下来调用 `findViewById(int)` 方法获取到 `MapView` 的对象。

    ```java
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        SDKInitializer.initialize(getApplicationContext());
        setContentView(R.layout.activity_main);
        mapView = (MapView) findViewById(R.id.bmapView);
    }
    ```

3. 管理生命周期

    在 `onResume()` ， `onPause()` 和 `onDestroy()` 方法中对 `MapView` 进行管理，以保证资源能够及时地得到释放。

    ```java
    @Override
    protected void onResume() {
        super.onResume();
        mapView.onResume();
    }

    @Override
    protected void onPause() {
        super.onPause();
        mapView.onPause();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        mapView.onDestroy();
    }
    ```

4. 控制地图

    调用 `MapView` 的 `getMap()` 方法可以获取到 `BaiduMap` 对象，可以通过该对象对 MapView 进行操作。

    - 缩放

        `MapStatusUpdateFactory` 的 `zoomTo(float)` 方法用于设置缩放级别。该方法接收一个 `float` 类型的参数，范围限定为 3 至 19 之间。 `zoomTo(float)` 方法返回一个 `MapStatusUpdate` 对象，把这个对象传入 `BaiduMap` 的 `animateMapStatus(MapStatusUpdate)` 方法中即可完成缩放功能。

        ```java
        MapStatusUpdate update = MapStatusUpdateFactory.zoomTo(12.5f);
        baiduMap.animateMapStatus(update);
        ```

    - 移动

        借助 `LatLng` 类可以将地图移动到某一个经纬度上。 `LatLng` 的构造方法接收两个 `double` 参数，第一个参数是纬度值，第二个参数是经度值。然后调用 `MapStatusUpdateFactory` 的 `newLatLng(LatLng)` 方法将 `LatLng` 对象传入。 `newLatLng(LatLng)` 方法返回一个 `MapStatusUpdate` 对象，把这个对象传入 `BaiduMap` 的 `animateMapStatus(MapStatusUpdate)` 方法当中，就可以将地图移动到指定的经纬度上了。

        ```java
        LatLng ll = new LatLng(39.915, 116.404);
        MapStatusUpdate update = MapStatusUpdateFactory.newLatLng(ll);
        baiduMap.animateMapStatus(update);
        ```

5. 显示设备当前位置

通过 `MyLocationData.Builder` 类，可以封装设备当前所在位置。我们需要将经纬度信息传入到这个类的相应方法当中。调用 `build()` 方法，会生成一个 `MyLocationData` 的对象，然后将这个对象传入到 `BaiduMap` 的 `setMyLocationData()` 方法中，就可以在地图上显示设备当前的位置了。

此功能需要先调用 `BaiduMap` 的 `setMyLocationEnabled(boolean)` 方法开启，否则设备的位置将无法在地图上显示。而在程序退出的时候，也要关闭此功能。

```java
MyLocationData.Builder locationBuilder = new MyLocationData.Builder();
locationBuilder.latitude(39.915);
locationBuilder.longitude(116.404);
MyLocationData locationData = locationBuilder.build();
baiduMap.setMyLocationData(locationData);
```

[↑目录](#index)

------

<h2 id="chap12">第12章 Material Design</h2>

`Material Design` 是 Google 在 2014 年 I/O 大会上推出的一套全新界面设计语言。在 2015 年的 I/O 大会上， Google 推出了 `Design Support` 库，将 Material Design 中最具代表性的控件和效果进行了封装，使开发者在不了解 Material Design 的情况下也能轻松地将应用 Material Design 化。

![各属性指定颜色](https://developer.android.google.cn/training/material/images/ThemeColors.png "theme color")

### ToolBar

`ToolBar` 是 `ActionBar` 的替代控件。在项目中需要先指定一个不带 `ActionBar` 的主题，如 `Theme.AppCompact.Light.NoActionBar` ，然后在布局文件中添加 `ToolBar` 。这里使用 `android:theme` 属性将 Toolbar 的主题指定为 `ThemeOverlay.AppCompat.Dark.ActionBar` 。使用 `app:popupTheme` 属性单独将弹出的菜单项指定为淡色主题。在实际中要根据需求选择主题。

```xml
<android.support.v7.widget.Toolbar
    android:id="@+id/toolbar"
    android:layout_width="match_parent"
    android:layout_height="?attr/actionBarSize"
    android:background="?attr/colorPrimary"
    android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
    app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/>
```

在 Activity 中，首先获取 `ToolBar` 的对象，然后调用 `setSupportActionBar(ToolBar)` 方法将 ToolBar 指定为系统 ActionBar 。

```java
Toolbar toolBar = (Toolbar) findViewById(R.id.toolbar);
setSupportActionBar(toolBar);
```

可以通过在 `AndroidManifests.xml` 的对应 `<activity>` 标签中添加 `android:lable` 属性来指定 ToolBar 中显示的文字内容。若未指定，则使用 `<application>` 中指定的 `android:lable` 属性。

```xml
<activity
    android:lable="[ToolBar_Text]"
    ...
    />
```

ToolBar 还可以添加按钮。将按钮图标放到 `drawable` 目录对应的文件夹中。在工程的 `res` 文件夹新建一个 `menu` 文件夹，在其中创建对应的 `xml` 文件定义按钮。每个 `<item>` 标签对应一个按钮。 `android:id` 属性用于指定按钮的 id ， `android:icon` 属性用于指定按钮的图标， `android:title` 属性用于指定按钮的文字。 `app:showAsAction` 有以下几种值可选： `always` 表示永远显示在 Toolbar 中，如果屏幕空间不够则不显示。 `ifRoom` 表示屏幕空间足够的情况下显示在 Toolbar 中，不够就显示在菜单当中。 `never` 则表示永远显示在菜单当中。 Toolbar 中的 action 按钮只显示图标，菜单中的 action 按钮只显示文字。

```xml
<item
    android:id="@+id/[button_id]"
    android:icon="@drawable/[drawable_id]"
    android:title="[button_text]"
    app:showAsAction="[always|ifRoom|never]"/>
```

最后，重写 `onCreateOptionsMenu(Menu)` 方法，加载对应的 `xml` 文件。并且重写 `onOptionsItemSelected(MenuItem)` 方法处理各个按钮的点击事件。

```java
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.[menu_file], menu);
    return true;
}

@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.[button_id]:
            // 按钮点击逻辑
        break;

        ...
    }
    return true;
}
```

### DrawerLayout

`DrawerLayout` 实现了滑动菜单效果。在 `DrawerLayout` 中只允许放入两个直接子控件。第一个子控件是主屏幕中显示的内容，第二个子控件是滑动菜单中显示的内容。第二个子控件必须指定 `layout_gravity` 属性。指定为 `left` 表示滑动菜单在左边，指定为 `right` 表示滑动菜单在右边。若指定为 `start` 或 `end` 则根据系统语言判断位置。

```xml
    <android.support.v4.widget.DrawerLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:id="@+id/drawer_layout"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <FrameLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent">
            ...
        </FrameLayout>

        <FrameLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_gravity="start">
            ...
        </FrameLayout>
    </android.support.v4.widget.DrawerLayout>
```

为了使用户更容易发现滑动菜单， Material Design 建议在 Toolbar 的最左侧加入一个导航按钮，点击按钮会展示滑动菜单的内容。首先得到 `DrawerLayout` 的对象，然后调用 `getSupportActionBar()` 方法得到了 `ActionBar` 的对象。接着调用 `ActionBar` 的 `setDisplayHomeAsUpEnabled(boolean)` 方法显示导航按钮。这个按钮叫作 `HomeAsUp` 按钮，默认图标是一个返回的箭头，含义是返回上一个 Activity 。可以调用 `setHomeAsUpIndicator(int)` 方法设置一个图标。接下来重写 `onOptionsItemSelected(MenuItem)` 方法对 HomeAsUp 按钮的点击事件进行处理。 HomeAsUp 按钮的 id 永远是 `android.R.id.home` 。在点击事件中调用 `DrawerLayout` 的 `openDrawer(int)` 方法展示滑动菜单。该方法要传入一个 `Gravity` 参数，要保证这里的行为和布局文件中定义的一致。

```java
    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        ...
        mDrawer = (DrawerLayout) findViewById(R.id.drawer_layout);
        Toolbar toolBar = (Toolbar) findViewById(R.id.toolbar);

        // 设置汉堡菜单图标及其监听
        ActionBarDrawerToggle drawerToggle = new ActionBarDrawerToggle(
                this, drawer, toolbar, R.string.menu_open, R.string.menu_close);
        drawerToggle.syncState();
        drawer.addDrawerListener(drawerToggle);

        setSupportActionBar(toolBar);
        ActionBar actionBar = getSupportActionBar();
        if (null != actionBar) {
            actionBar.setDisplayHomeAsUpEnabled(true);
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                mDrawer.openDrawer(GravityCompat.START);
                break;
            ...
        }
        return true;
    }
```

### NavigationView

`NavigationView` 是 `Design Support` 库中提供的一个控件，它严格按照 Material Design 的要求实现滑动菜单页面。使用 `NavigationView` 需要添加依赖项：

```groovy
compile 'com.android.support:design:26.1.0'
```

在 `layout` 目录下定义顶部的布局文件。一般最外层布局的宽度为 `match_parent` ，高度为定值。该布局将用于 `NavigationView` 的顶部视图。在 `res/menu` 目录下创建导航项目的 XML 文件。最外层是 `<menu>` 标签。在 `<menu>` 标签中嵌套一个 `<group>` 标签表示一个组，然后将 `<group>` 标签的 `android:checkableBehavior` 属性指定为 `single` 表示组中的所有菜单项只能单选。在 `<group>` 标签中添加 `<item>` 标签表示组中的菜单项。使用 `android:id` 属性指定菜单项的 id ， `android:icon` 属性指定菜单项的图标， `android:title` 属性指定菜单项显示的文字。

使用 `NavigationView` 实现侧滑菜单，需要配合 `DrawerLayout` 实现。将 `NavigationView` 作为 `DrawerLayout` 的第二个子控件即可。通过 `app:headerLayout` 属性指定顶部布局，通过 `app:menu` 属性指定导航项目。

```xml
<android.support.design.widget.NavigationView
    android:id="@+id/nav_view"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_gravity="start"
    app:headerLayout="@layout/[header_layout]"
    app:menu="@menu/[nav_menu]"/>
```

在 Activity 中，首先获取 `NavigationView` 的对象。然后可以调用它的 `setCheckedItem(int)` 方法将某个菜单项设置为默认选中。接着调用 `setNavigationItemSelectedListener(OnNavigationItemSelectedListener)` 方法设置菜单项选中事件的监听器。当用户点击了任意菜单项时，就会回调到 `onNavigationItemSelected(MenuItem)` 方法中，在这个方法中执行相应的逻辑处理。

```java
NavigationView navView = (NavigationView) findViewById(R.id.nav_view);
navView.setCheckedItem([item_id]);
navView.setNavigationItemSelectedListener(new OnNavigationItemSelectedListener() {
    @Override
    public boolean onNavigationItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case [item_id]:
                // 选中菜单项执行的逻辑
                break;
            ...
        }
        return true;
    }
});
```

### FloatingActionButton

`FloatingActionButton` 是 Design Support 库中提供的一个控件，这个控件可以实现悬浮按钮效果。使用 `FloatingActionButton` 需要添加依赖项：

```groovy
compile 'com.android.support:design:26.1.0'
```

在布局中添加 `FloatingActionButton` 。其默认颜色为 `@color/colorAccent` 。使用 `android:src` 属性可以指定其图标。使用 `app:elevation` 属性可以更改其高度，改变阴影大小。

```xml
<android.support.design.widget.FloatingActionButton
    android:id="@+id/fab"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_gravity="end|bottom"
    android:layout_margin="16dp"/>
```

在 Activity 中可以对 `FloatingActionButton` 设置点击时间监听。

```java
FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab_main);
fab.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick(View v) {
        // 点击事件逻辑
    }
});
```

### SnackBar

`SnackBar` 是一个提示工具。它带有一个可以交互的按钮，可以执行额外的逻辑。使用 `SnackBar` 需要添加 Design Support 库依赖项：

```groovy
compile 'com.android.support:design:26.1.0'
```

`SnackBar` 的用法类似于 `Toast` 。调用 `Snackbar` 的 `make(View, CharSequence, int)` 方法可以创建一个 `Snackbar` 对象。该方法的第一个 `View` 参数需要传入当前界面布局的任意一个 View 。 Snackbar 会使用这个 View 自动查找最外层布局，用于展示 Snackbar 。第二个 `CharSequence` 参数是 Snackbar 中显示的内容。第三个 `int` 参数是 Snackbar 显示的时长。然后调用了 `setAction(CharSequence, OnClickListener)` 方法可以设置一个动作，从而和用户进行交互。该方法第一个 `CharSequence` 参数是按钮的文字，第二个 `OnClickListener` 参数是按钮点击事件的监听。最后调用 `show()` 方法显示 Snackbar 。

```java
Snackbar.make([view], [hint_text], Snackbar.LENGTH_SHORT)
        .setAction([button_text], new OnClickListener() {
            @Override
            public void onClick(View v) {
                // 点击按钮的逻辑
            }
        })
        .show();
```

### CoordinatorLayout

`CoordinatorLayout` 可以监听其所有子控件的各种事件，然后自动做出最为合理的响应。使用 `CoordinatorLayout` 需要添加 Design Support 库依赖项：

```groovy
compile 'com.android.support:design:26.1.0'
```

`CoordinatorLayout` 的使用方法和 `FrameLayout` 相同。

### CardView

`CardView` 用于实现卡片式布局效果。 `CardView` 本质是一个 `FrameLayout` ，额外提供了圆角和阴影等效果，看上去会有立体感。使用 `CardView` 需要添加其依赖项：

```groovy
compile 'com.android.support:cardview-v7:26.1.0'
```

`CardView` 可以使用 `app:cardCornerRadius` 属性指定圆角的大小，使用 `app:cardElevation` 属性指定卡片的高度，即阴影的大小。

```xml
<android.support.v7.widget.CardView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_gravity="center"
    app:cardCornerRadius="4dp"
    app:cardElevation="4dp"/>
```

### AppBarLayout

`AppBarLayout` 是一个垂直方向的 `LinearLayout` 。它在内部做了很多滚动事件的封装，并应用了一些 Material Design 的设计理念。该控件可用于外层是 `CoordinatorLayout` ，内部是 `Toolbar` 与 `RecyclerView` 组合的页面。使用 `AppBarLayout` 需要添加 Design Support 库依赖项：

```groovy
compile 'com.android.support:design:26.1.0'
```

使用 `AppBarLayout` ，要先为其添加一个 `Toolbar` 子控件，再为 `Toolbar` 和 `RecyclerView` 分别指定布局行为。

```xml
<android.support.design.widget.CoordinatorLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <android.support.design.widget.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <android.support.v7.widget.Toolbar
            android:id="@+id/tool_bar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:background="?attr/colorPrimary"
            android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
            app:layout_scrollFlags="scroll|enterAlways|snap"
            app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/>
    </android.support.design.widget.AppBarLayout>

    <android.support.v7.widget.RecyclerView
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior"/>
</android.support.design.widget.CoordinatorLayout>
```

在 `RecyclerView` 中使用 `app:layout_behavior` 属性指定了一个布局行为。其中 `appbar_scrolling_view_behavior` 也是由 Design Support 库提供的。在 `Toolbar` 中添加了 `app:layout_scrollFlags` 属性并将值指定成了 `scroll|enterAlways|snap` 。其中， `scroll` 表示当 RecyclerView 向上滚动时 Toolbar 会一起向上滚动并实现隐藏。 `enterAlways` 表示当 RecyclerView 向下滚动的时候 Toolbar 会一起向下滚动并重新显示。 `snap` 表示当 Toolbar 还没有完全隐藏或显示时会根据当前滚动的距离，自动选择是隐藏或显示。

### SwipeRefreshLayout

`SwipeRefreshLayout` 用于实现下拉刷新功能。把想要实现下拉刷新功能的控件放置到 `SwipeRefreshLayout` 中，就可以迅速让这个控件支持下拉刷新。

```xml
<android.support.v4.widget.SwipeRefreshLayout
    android:id="@+id/swipe_refresh"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <android.support.v7.widget.RecyclerView
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
</android.support.v4.widget.SwipeRefreshLayout>
```

在 Activity 中，首先获取 `SwipeRefreshLayout` 的对象。调用 `setColorSchemeResources(int...)` 方法设置下拉刷新进度条的颜色。调用 `setOnRefreshListener(OnRefreshListener)` 方法可以设置下拉刷新的监听器。当触发了下拉刷新操作时会回调这个监听器的 `onRefresh()` 方法，在这里处理具体的刷新逻辑。最后在主线程调用 `setRefreshing(boolean)` 方法并传入 `false` 隐藏刷新进度条。

```java
swipeRefresh = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh);
swipeRefresh.setColorSchemeResources(R.color.colorPrimary);
swipeRefresh.setOnRefreshListener(new OnRefreshListener() {
    @Override
    public void onRefresh() {
        // 刷新的逻辑
        ...
        // 停止显示刷新动画
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                swipeRefresh.setRefreshing(false);
            }
        });
    }
});
```

### CollapsingToolbarLayout

### 利用系统状态栏空间

[↑目录](#index)

------

<h2 id="chap13">第13章 高级技巧</h2>

[↑目录](#index)

<h2 id="chap14">第14章 酷欧天气</h2>

[↑目录](#index)

<h2 id="chap15">第15章 发布应用</h2>

[↑目录](#index)

<h2 id="git">Git 时间</h2>

### 安装 git

- Ubuntu

    `sudo apt-get install git-core`

- Windows

    `https://git-for-windows.github.io/`

安装完成后，你需要配置一下自己的身份。

```shell
git config --global user.name "your_name"
git config --global user.email "your_email"
```

### 创建代码仓库

仓库（Repository）是用于保存版本管理所需信息的地方。所有本地提交的代码都会提交到本地 Repository 中， 如果有需还可以再推送到远程 Repository 中。在项目目录下输入 `git init` 即可创建本地 Repository 。 Repository 创建完成后，会在目的根目录下生成一个隐藏的 `.git` 文件夹。如果想要删除本地 Repository ，只需要删除这个文件夹就行了。

### 提交本地代码

使用 `add` 和 `commit` 命令。 `add` 用于添加要提交的代码， `commit` 用于执行提交操作。

```shell
git add [file-name]
git add [directory-name]
git add .
```

`commit` 命令一定要添加 `-m` 参数来加上提交的描述信息，没有描述信息的提交被认为是不合法的。

```shell
git commit -m "[comment]"
```

### 忽略文件

git 会检查代码仓库目录下是否存在 `.gitignore` 文件。如果存在，就去一行行读取文件中的内容，并把每一行指定的文件或目录排除在版本控制之外。注意 `.gitignore` 中指定的文件或目录可以使用 `*` 通配符。

### 查看修改文件

查看文件修改情况的命令：

```shell
git status
```

查看文件更改内容的命令：

```shell
git diff [file-name]
```

### 撤销未提交的修改

对于没有执行过 `add` 命令的文件，撤销更改可以使用 `checkout` 命令。

```shell
git checkout [file-name]
```

对于执行过 `add` 命令的文件，应先取消添加再撤销更改。

```shell
git reset HEAD [file-name]
git checkout [file-name]
```

### 查看提交记录

可以使用 `log` 命令查看历史提交信息。每次提交记录都会包含 `提交id` ， `提交人` ， `提交日期` 及 `提交描述` 4 个信息。

```shell
git log
```

如果只想查看其中一条记录，可以在命令中指定该记录的 id ，并加上 `-1` 参数表示只想看到一行记录。如果想要查看这条提交记录具体修改的内容，可以在命令中加入 `-p` 参数。

```shell
git log [id] -1 -p
```

### 分支

分支主要作用是在现有代码的基础上开辟一个分叉口，使得代码可以在主干线和分支线上同时进行开发，且相互之间不会影响。

- 查看分支

    ```shell
    git branch
    ```

- 创建分支

    ```shell
    git branch [branch-name]
    ```

- 切换分支

    ```shell
    git checkout [branch-name]
    ```

- 合并分支

    将 `branch2` 合并到 `master` 上

    ```shell
    git checkout master
    git merge branch2
    ```

- 删除分支

    ```shell
    git branch -D [branch-name]
    ```

### 远程版本库

从远程版本库下载代码：

```shell
git clone [remote-url]
```

将本地修改推送到远程版本库：

```shell
git push origin [branch-name]
```

`fetch` 命令将远程版本库代码同步到本地，并存放到 `origin/[branch-name]` 分支上。然后我们可以通过 `diff` 命令对比修改，然后根据需要进行 `merge` 操作。

```shell
git fetch origin [branch-name]
git diff origin/[branch-name]
git merge origin/[branch-name]
```

也可以通过 `pull` 命令直接同步并合并：

```shell
git pull origin [branch-name]
```

[↑目录](#index)
